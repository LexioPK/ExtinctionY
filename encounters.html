<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wild Encounters</title>

    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Standardized header styles & script -->
    <link rel="stylesheet" href="header.css">
    <script src="header.js" defer></script>

    <link rel="stylesheet" href="style.css">
    <style>
        :root {
            --border-thick: 2px;
            --border-color: #6f6f6f;
            --pokemon-border-color: #555555;
            --inner-padding-x: 10px;
            --inner-padding-y: 12px;
            --separator-thick: 4px;
            --sep-color: #e6e6e6;
        }

        body {
            font-family: 'Lexend', sans-serif;
            background: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
        }

        .sidebar {
            position: fixed;
            top: 65px;
            left: 0;
            width: 320px;
            height: calc(100vh - 65px);
            background: white;
            overflow-y: auto;
            box-shadow: 3px 0 8px rgba(0,0,0,0.07);
            padding: 15px;
        }

        .location-tab {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: #f2f2f2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .location-tab:hover {
            background: #e3e3e3;
        }

        .location-tab.active {
            background: #1976d2;
            color: white;
            font-weight: 600;
        }

        .encounters-section {
            padding: 20px;
            max-width: 1600px;
            margin-left: 340px;
            margin-top: 90px;
            width: calc(100% - 340px);
        }

        .location-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .area-title {
            font-size: 1.8rem;
            font-weight: 700;
            flex: 1;
            text-align: center;
        }
        
        .nav-button {
            padding: 10px 20px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background 0.2s;
            min-width: 120px;
        }
        
        .nav-button:hover:not(:disabled) {
            background: #1565c0;
        }
        
        .nav-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .encounter-type-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .encounter-type-header {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #1976d2;
        }

        .items-section {
            background: #6a6a6a;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .pokemon-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }

        .pokemon-box {
            background: #fafafa;
            border: 2px solid var(--pokemon-border-color);
            border-radius: 10px;
            padding: 10px;
            width: 100px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .pokemon-name {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }

        .pokemon-icon {
            width: 60px;
            height: 60px;
            object-fit: contain;
            image-rendering: pixelated;
            margin: 5px auto;
            display: block;
            cursor: pointer;
        }
        
        .pokemon-icon:hover {
            opacity: 0.8;
            transform: scale(1.05);
            transition: all 0.2s ease;
        }

        .pokemon-chance {
            font-weight: 600;
            color: #1976d2;
            margin-top: 5px;
        }

        .na-message {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        @media (max-width: 520px) {
            .sidebar {
                display: none;
            }
            .encounters-section { 
                margin-left: 16px; 
                width: calc(100% - 16px); 
            }
            .pokemon-box {
                width: 100%;
            }
        }
    </style>
</head>

<body>

<div class="sidebar" id="sidebar"></div>

<div class="encounters-section" id="encountersSection"></div>

<script>
    let encounterData = [];
    let pokedexData = {};
    let itemsData = [];

    async function loadEncounters() {
        const sidebar = document.getElementById("sidebar");

        try {
            // Fetch encounters, pokedex, and items data
            const [encountersRes, pokedexRes, itemsRes] = await Promise.all([
                fetch("data/encounters.json"),
                fetch("data/pokedex.json"),
                fetch("data/items.json").catch(() => null) // Handle if items.json doesn't exist yet
            ]);
            
            if (!encountersRes.ok || !pokedexRes.ok) {
                throw new Error("Failed to load encounter data");
            }
            
            encounterData = await encountersRes.json();
            pokedexData = await pokedexRes.json();
            
            // Load items data if available
            if (itemsRes && itemsRes.ok) {
                itemsData = await itemsRes.json();
            }
            
            // Special cave entries - keep all under unified name
            // Reflection Cave: LocationIDs 305, 306, 307, 308 → Combined as "Reflection Cave"
            // Frost Cavern: LocationIDs 313, 314, 315, 316, 317 → Combined as "Frost Cavern"
            // Terminus Cave: LocationIDs 343, 344, 345, 347, 348 → Combined as "Terminus Cave"
            // Victory Road: LocationIDs 322, 324, 326, 327, 328 → Combined as "Victory Road"
            
            // Define the desired order of locations
            const locationOrder = [
                "Vaniville Town",
                "Route 1",
                "Aquacorde Town",
                "Route 2",
                "Santalune Forest",
                "Route 3",
                "Santalune City",
                "Route 22",
                "Route 4",
                "Lumiose City",
                "Route 5",
                "Camphrier Town",
                "Kalos Hotels",
                "Route 6",
                "Berry Fields",
                "Parfum Palace",
                "Route 7",
                "Connecting Cave",
                "Route 8",
                "Ambrette Town",
                "Route 9",
                "Glittering Cave",
                "Cyllage City",
                "Route 10",
                "Geosenge Town",
                "Route 11",
                "Reflection Cave",
                "Shalour City",
                "Tower of Mastery",
                "Route 12",
                "Azure Bay",
                "Coumarine City",
                "Route 13",
                "Kalos Power Plant",
                "Route 14",
                "Laverre City",
                "Poké Ball Factory",
                "Route 15",
                "Route 16",
                "Lost Hotel",
                "Dendemille Town",
                "Frost Cavern",
                "Route 17",
                "Anistar City",
                "Route 18",
                "Terminus Cave",
                "Couriway Town",
                "Route 19",
                "Snowbelle City",
                "Route 20",
                "Pokémon Village",
                "Route 21",
                "Chamber of Emptiness",
                "Victory Road",
                "Unknown Dungeon",
                "Kiloude City"
            ];
            
            // Reorder encounterData based on locationOrder
            // Group locations by name to handle duplicates (like Terminus Cave)
            const orderedEncounterData = [];
            const encounterMap = new Map();
            
            // Create a map with arrays for locations with same name
            encounterData.forEach(location => {
                if (!encounterMap.has(location.LocationName)) {
                    encounterMap.set(location.LocationName, []);
                }
                encounterMap.get(location.LocationName).push(location);
            });
            
            // Add locations in the specified order
            locationOrder.forEach(locationName => {
                if (encounterMap.has(locationName)) {
                    // Add all instances of this location name
                    orderedEncounterData.push(...encounterMap.get(locationName));
                    encounterMap.delete(locationName);
                }
            });
            
            // Add any remaining locations not in the order list
            encounterMap.forEach(locationsList => {
                orderedEncounterData.push(...locationsList);
            });
            
            // Replace encounterData with ordered version
            encounterData = orderedEncounterData;
        } catch (error) {
            console.error("Error loading encounters:", error);
            sidebar.innerHTML = '<div style="padding: 20px; color: #d32f2f;">Error loading encounter data. Please refresh the page.</div>';
            return;
        }

        // Build sidebar tabs from encounter locations (unique names only)
        const uniqueLocationNames = [];
        const locationNameToIndices = new Map();
        
        encounterData.forEach((location, index) => {
            if (!locationNameToIndices.has(location.LocationName)) {
                uniqueLocationNames.push(location.LocationName);
                locationNameToIndices.set(location.LocationName, []);
            }
            locationNameToIndices.get(location.LocationName).push(index);
        });
        
        uniqueLocationNames.forEach((locationName) => {
            const tab = document.createElement("div");
            tab.className = "location-tab";
            tab.textContent = locationName;
            tab.onclick = () => {
                document.querySelectorAll(".location-tab").forEach(t => t.classList.remove("active"));
                tab.classList.add("active");
                // Display all encounters for this location name
                displayLocationByName(locationName, locationNameToIndices.get(locationName));
            };
            sidebar.appendChild(tab);
        });

        // Activate first tab if present
        if (sidebar.children.length && uniqueLocationNames.length > 0) {
            sidebar.children[0].classList.add("active");
            displayLocationByName(uniqueLocationNames[0], locationNameToIndices.get(uniqueLocationNames[0]));
        }
    }

    function displayLocationByName(locationName, indices) {
        const container = document.getElementById("encountersSection");
        container.innerHTML = "";
        
        // Get navigation info
        const allTabs = Array.from(document.querySelectorAll(".location-tab"));
        const currentTabIndex = allTabs.findIndex(tab => tab.textContent === locationName);
        const hasPrev = currentTabIndex > 0;
        const hasNext = currentTabIndex < allTabs.length - 1;
        
        // Helper function to create navigation buttons
        function createNavigationButtons(includeTitle = true) {
            const navContainer = document.createElement("div");
            navContainer.className = "location-header-container";
            
            // Previous button
            const prevButton = document.createElement("button");
            prevButton.className = "nav-button";
            prevButton.innerHTML = "← " + (hasPrev ? allTabs[currentTabIndex - 1].textContent : "Previous Location");
            prevButton.disabled = !hasPrev;
            if (hasPrev) {
                prevButton.onclick = () => allTabs[currentTabIndex - 1].click();
            }
            navContainer.appendChild(prevButton);
            
            // Title (optional)
            if (includeTitle) {
                const title = document.createElement("h2");
                title.textContent = locationName;
                title.style.margin = "0 20px";
                navContainer.appendChild(title);
            }
            
            // Next button
            const nextButton = document.createElement("button");
            nextButton.className = "nav-button";
            nextButton.innerHTML = (hasNext ? allTabs[currentTabIndex + 1].textContent : "Next Location") + " →";
            nextButton.disabled = !hasNext;
            if (hasNext) {
                nextButton.onclick = () => allTabs[currentTabIndex + 1].click();
            }
            navContainer.appendChild(nextButton);
            
            return navContainer;
        }
        
        // Add navigation at the top
        container.appendChild(createNavigationButtons(true));
        
        // Check for special cave locations with floor/room designations
        if (locationName === "Reflection Cave") {
            // First 2 (305, 306) → "Floor 1, B Floor 1", Last 2 (307, 308) → "B Floor 2-3"
            let floor1Index = null;
            let floor2Index = null;
            
            indices.forEach((locationIndex) => {
                const location = encounterData[locationIndex];
                if (!location) return;
                const locId = location.LocationID;
                if ((locId === 305 || locId === 306) && floor1Index === null) {
                    floor1Index = locationIndex;
                } else if ((locId === 307 || locId === 308) && floor2Index === null) {
                    floor2Index = locationIndex;
                }
            });
            
            if (floor1Index !== null) {
                const floor1Encounters = aggregateEncountersForIndices([floor1Index]);
                const floorHeader = document.createElement("h3");
                floorHeader.textContent = "Reflection Cave - Floor 1, B Floor 1";
                floorHeader.style.marginTop = "30px";
                floorHeader.style.marginBottom = "20px";
                floorHeader.style.fontSize = "1.5rem";
                floorHeader.style.fontWeight = "700";
                floorHeader.style.color = "#333";
                container.appendChild(floorHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", floor1Encounters.grass);
                displayEncounterSection(container, "Fishing", floor1Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", floor1Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", floor1Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", floor1Encounters.hordes);
            }
            
            if (floor2Index !== null) {
                const floor2Encounters = aggregateEncountersForIndices([floor2Index]);
                const floorHeader = document.createElement("h3");
                floorHeader.textContent = "Reflection Cave - B Floor 2-3";
                floorHeader.style.marginTop = "30px";
                floorHeader.style.marginBottom = "20px";
                floorHeader.style.fontSize = "1.5rem";
                floorHeader.style.fontWeight = "700";
                floorHeader.style.color = "#333";
                container.appendChild(floorHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", floor2Encounters.grass);
                displayEncounterSection(container, "Fishing", floor2Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", floor2Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", floor2Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", floor2Encounters.hordes);
            }
        } else if (locationName === "Frost Cavern") {
            // Combine first two (313, 314) only, ignore the rest (315, 316, 317)
            const frostIndices = [];
            indices.forEach((locationIndex) => {
                const location = encounterData[locationIndex];
                if (!location) return;
                const locId = location.LocationID;
                if (locId === 313 || locId === 314) {
                    frostIndices.push(locationIndex);
                }
            });
            
            const frostEncounters = aggregateEncountersForIndices(frostIndices);
            displayEncounterSection(container, "Grass / Terrain Encounters", frostEncounters.grass);
            displayEncounterSection(container, "Fishing", frostEncounters.fishing);
            displayEncounterSection(container, "Rock Smash", frostEncounters.rockSmash);
            displayEncounterSection(container, "Surfing", frostEncounters.surfing);
            displayEncounterSection(container, "Horde Encounters", frostEncounters.hordes);
        } else if (locationName === "Victory Road") {
            // First 2 (322, 324) → "Room 1 & 2", Next 3 (326, 327, 328) → "Room 3 & 4"
            let room1Index = null;
            let room3Index = null;
            
            indices.forEach((locationIndex) => {
                const location = encounterData[locationIndex];
                if (!location) return;
                const locId = location.LocationID;
                if ((locId === 322 || locId === 324) && room1Index === null) {
                    room1Index = locationIndex;
                } else if ((locId === 326 || locId === 327 || locId === 328) && room3Index === null) {
                    room3Index = locationIndex;
                }
            });
            
            if (room1Index !== null) {
                const room1Encounters = aggregateEncountersForIndices([room1Index]);
                const roomHeader = document.createElement("h3");
                roomHeader.textContent = "Victory Road - Room 1 & 2";
                roomHeader.style.marginTop = "30px";
                roomHeader.style.marginBottom = "20px";
                roomHeader.style.fontSize = "1.5rem";
                roomHeader.style.fontWeight = "700";
                roomHeader.style.color = "#333";
                container.appendChild(roomHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", room1Encounters.grass);
                displayEncounterSection(container, "Fishing", room1Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", room1Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", room1Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", room1Encounters.hordes);
            }
            
            if (room3Index !== null) {
                const room3Encounters = aggregateEncountersForIndices([room3Index]);
                const roomHeader = document.createElement("h3");
                roomHeader.textContent = "Victory Road - Room 3 & 4";
                roomHeader.style.marginTop = "30px";
                roomHeader.style.marginBottom = "20px";
                roomHeader.style.fontSize = "1.5rem";
                roomHeader.style.fontWeight = "700";
                roomHeader.style.color = "#333";
                container.appendChild(roomHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", room3Encounters.grass);
                displayEncounterSection(container, "Fishing", room3Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", room3Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", room3Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", room3Encounters.hordes);
            }
        } else if (locationName === "Terminus Cave") {
            // First 3 (343, 344, 345) → "Floor 1-2, B Floor 1", Last 2 (347, 348) → "B Floor 2-3"
            let floor1Index = null;
            let floor2Index = null;
            
            indices.forEach((locationIndex) => {
                const location = encounterData[locationIndex];
                if (!location) return;
                const locId = location.LocationID;
                if ((locId === 343 || locId === 344 || locId === 345) && floor1Index === null) {
                    floor1Index = locationIndex;
                } else if ((locId === 347 || locId === 348) && floor2Index === null) {
                    floor2Index = locationIndex;
                }
            });
            
            if (floor1Index !== null) {
                const floor1Encounters = aggregateEncountersForIndices([floor1Index]);
                const floorHeader = document.createElement("h3");
                floorHeader.textContent = "Terminus Cave - Floor 1-2, B Floor 1";
                floorHeader.style.marginTop = "30px";
                floorHeader.style.marginBottom = "20px";
                floorHeader.style.fontSize = "1.5rem";
                floorHeader.style.fontWeight = "700";
                floorHeader.style.color = "#333";
                container.appendChild(floorHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", floor1Encounters.grass);
                displayEncounterSection(container, "Fishing", floor1Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", floor1Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", floor1Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", floor1Encounters.hordes);
            }
            
            if (floor2Index !== null) {
                const floor2Encounters = aggregateEncountersForIndices([floor2Index]);
                const floorHeader = document.createElement("h3");
                floorHeader.textContent = "Terminus Cave - B Floor 2-3";
                floorHeader.style.marginTop = "30px";
                floorHeader.style.marginBottom = "20px";
                floorHeader.style.fontSize = "1.5rem";
                floorHeader.style.fontWeight = "700";
                floorHeader.style.color = "#333";
                container.appendChild(floorHeader);
                
                displayEncounterSection(container, "Grass / Terrain Encounters", floor2Encounters.grass);
                displayEncounterSection(container, "Fishing", floor2Encounters.fishing);
                displayEncounterSection(container, "Rock Smash", floor2Encounters.rockSmash);
                displayEncounterSection(container, "Surfing", floor2Encounters.surfing);
                displayEncounterSection(container, "Horde Encounters", floor2Encounters.hordes);
            }
        } else {
            // Normal aggregation for other locations
            const aggregatedEncounters = aggregateEncountersForIndices(indices);
            
            // Display each encounter type section
            displayEncounterSection(container, "Grass / Terrain Encounters", aggregatedEncounters.grass);
            displayEncounterSection(container, "Fishing", aggregatedEncounters.fishing);
            displayEncounterSection(container, "Rock Smash", aggregatedEncounters.rockSmash);
            displayEncounterSection(container, "Surfing", aggregatedEncounters.surfing);
            displayEncounterSection(container, "Horde Encounters", aggregatedEncounters.hordes);
        }
        
        // Display Items section
        displayItemsSection(container, locationName);
        
        // Add navigation buttons at the bottom (without title)
        const footerContainer = createNavigationButtons(false);
        footerContainer.style.marginTop = "30px";
        container.appendChild(footerContainer);
    }

    function aggregateEncountersForIndices(indices) {
        const aggregatedEncounters = {
            grass: [],
            fishing: [],
            rockSmash: [],
            surfing: [],
            hordes: []
        };
        
        // Collect all encounters across the provided indices
        indices.forEach((locationIndex) => {
            const location = encounterData[locationIndex];
            if (!location || !location.Encounters || !Array.isArray(location.Encounters)) return;
            
            location.Encounters.forEach(encounter => {
                const type = encounter.EncounterType.toLowerCase();
                
                if (type.includes('horde')) {
                    aggregatedEncounters.hordes.push(encounter);
                } else if (type.includes('rock smash')) {
                    aggregatedEncounters.rockSmash.push(encounter);
                } else if (type.includes('surf')) {
                    aggregatedEncounters.surfing.push(encounter);
                } else if (type.includes('rod')) {
                    aggregatedEncounters.fishing.push(encounter);
                } else {
                    // Grass, flowers, rough terrain, etc.
                    aggregatedEncounters.grass.push(encounter);
                }
            });
        });
        
        return aggregatedEncounters;
    }

    function normalizeForCompare(s) {
        return (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");
    }

    function findPokedexEntry(pokeName) {
        if (!pokedexData || !pokeName) return null;
        if (pokedexData[pokeName]) return pokedexData[pokeName];
        const target = normalizeForCompare(pokeName);
        for (const key in pokedexData) {
            if (normalizeForCompare(key) === target) return pokedexData[key];
        }
        return null;
    }

    function getPokemonIconPath(pokemonName) {
        // Normalize the pokemon name for the icon filename
        const normalized = pokemonName.toLowerCase().replace(/[^a-z0-9]/g, "");
        return `image/icons/${normalized}.png`;
    }

    function getItemIconPath(itemName) {
        // Strip any trailing dash and number (e.g., "Oran Berry-2" becomes "Oran Berry")
        let cleanedName = itemName.replace(/-\d+$/, '');
        
        // Special handling for TMs - if item starts with "TM", just use "tm" for the icon
        if (cleanedName.toUpperCase().startsWith('TM')) {
            return 'image/item/tm.png';
        }
        
        // Special handling for HMs - if item starts with "HM", just use "hm" for the icon
        if (cleanedName.toUpperCase().startsWith('HM')) {
            return 'image/item/hm.png';
        }
        
        // Convert item name to filename format (lowercase, replace spaces with hyphens)
        const filename = cleanedName.toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '') // Remove special characters except spaces and hyphens
            .replace(/\s+/g, '-') // Replace spaces with hyphens
            .replace(/-+/g, '-'); // Replace multiple hyphens with single
        return `image/item/${filename}.png`;
    }

    function parseAreaAndSubArea(area) {
        // Extract sub-area from parentheses
        const match = area.match(/^(.+?)\s*\((.+?)\)$/);
        if (match) {
            return {
                mainArea: match[1].trim(),
                subArea: match[2].trim()
            };
        }
        return {
            mainArea: area,
            subArea: ""
        };
    }

    function displayItemsSection(container, locationName) {
        const itemsSection = document.createElement("div");
        itemsSection.className = "items-section";
        itemsSection.style.marginTop = "30px";

        const header = document.createElement("h3");
        header.textContent = "Items";
        header.style.borderBottom = "2px solid #2196F3";
        header.style.paddingBottom = "10px";
        header.style.marginBottom = "20px";
        header.style.color = "#ffffff";
        itemsSection.appendChild(header);

        // Filter items for this location
        const locationItems = itemsData.filter(item => {
            const parsed = parseAreaAndSubArea(item.Area);
            return parsed.mainArea === locationName;
        });

        if (locationItems.length === 0) {
            const noItems = document.createElement("p");
            noItems.textContent = "Items information will be added in a future update.";
            noItems.style.color = "#cccccc";
            noItems.style.textAlign = "center";
            noItems.style.padding = "20px";
            itemsSection.appendChild(noItems);
        } else {
            // Group items by sub-area
            const itemsBySubArea = new Map();
            locationItems.forEach(item => {
                const parsed = parseAreaAndSubArea(item.Area);
                const subArea = parsed.subArea || "General";
                if (!itemsBySubArea.has(subArea)) {
                    itemsBySubArea.set(subArea, []);
                }
                itemsBySubArea.get(subArea).push(item);
            });

            // Display items grouped by sub-area
            itemsBySubArea.forEach((items, subArea) => {
                // Sub-area header (if not "General")
                if (subArea !== "General") {
                    const subAreaHeader = document.createElement("div");
                    subAreaHeader.textContent = subArea;
                    subAreaHeader.style.fontSize = "1.1rem";
                    subAreaHeader.style.fontWeight = "600";
                    subAreaHeader.style.marginTop = "20px";
                    subAreaHeader.style.marginBottom = "10px";
                    subAreaHeader.style.color = "#ffffff";
                    itemsSection.appendChild(subAreaHeader);
                }

                // Create items table
                const table = document.createElement("table");
                table.style.width = "100%";
                table.style.borderCollapse = "collapse";
                table.style.marginBottom = "20px";

                // Table header
                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr style="background-color: #f5f5f5; border-bottom: 2px solid #ddd;">
                        <th style="padding: 10px; text-align: center; width: 60px;">Icon</th>
                        <th style="padding: 10px; text-align: center;">Item</th>
                        <th style="padding: 10px; text-align: center;">Location/Price</th>
                    </tr>
                `;
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement("tbody");
                items.forEach((item, idx) => {
                    const row = document.createElement("tr");
                    row.style.borderBottom = "1px solid #eee";
                    if (idx % 2 === 0) {
                        row.style.backgroundColor = "#fafafa";
                    }

                    // Icon cell
                    const iconCell = document.createElement("td");
                    iconCell.style.padding = "10px";
                    iconCell.style.textAlign = "center";
                    const icon = document.createElement("img");
                    icon.src = getItemIconPath(item.Item);
                    icon.alt = item.Item;
                    icon.style.width = "40px";
                    icon.style.height = "40px";
                    icon.onerror = function() {
                        // Use substitute/unknown pokemon sprite as fallback
                        this.src = 'pokemon_sprites/unknown.png';
                        this.onerror = function() {
                            this.style.display = 'none';
                        };
                    };
                    iconCell.appendChild(icon);
                    row.appendChild(iconCell);

                    // Item name cell
                    const nameCell = document.createElement("td");
                    nameCell.style.padding = "10px";
                    nameCell.style.fontWeight = "600";
                    nameCell.textContent = item.Item;
                    row.appendChild(nameCell);

                    // Location/Price cell
                    const locationCell = document.createElement("td");
                    locationCell.style.padding = "10px";
                    locationCell.textContent = item["Location/Price"];
                    row.appendChild(locationCell);

                    tbody.appendChild(row);
                });
                table.appendChild(tbody);

                itemsSection.appendChild(table);
            });
        }

        container.appendChild(itemsSection);
    }

    function displayEncounterSection(container, sectionTitle, encounters) {
        // Skip empty encounter sections entirely
        if (encounters.length === 0) {
            return;
        }

        const section = document.createElement("div");
        section.className = "encounter-type-section";

        const header = document.createElement("div");
        header.className = "encounter-type-header";
        header.textContent = sectionTitle;
        section.appendChild(header);

        // Check if this is a horde section - handle specially
        const isHordeSection = sectionTitle.toLowerCase().includes('horde');
        
        if (isHordeSection) {
                // For hordes, combine all Pokemon across all horde types
                const pokemonBySpecies = new Map();
                
                encounters.forEach(encounter => {
                    const hordeMatch = encounter.EncounterType.match(/Horde \((\d+)%\)/);
                    const hordePercent = hordeMatch ? parseInt(hordeMatch[1]) : 0;
                    
                    encounter.Slots.forEach(slot => {
                        const species = slot.Species;
                        if (!pokemonBySpecies.has(species)) {
                            pokemonBySpecies.set(species, {
                                Species: species,
                                hordeTypes: [],
                                totalPercent: 0
                            });
                        }
                        const pokemonData = pokemonBySpecies.get(species);
                        if (!pokemonData.hordeTypes.includes(hordePercent)) {
                            pokemonData.hordeTypes.push(hordePercent);
                            pokemonData.totalPercent += hordePercent;
                        }
                    });
                });
                
                // Display all Pokemon in a single grid under the main header
                const grid = document.createElement("div");
                grid.className = "pokemon-grid";
                
                Array.from(pokemonBySpecies.values()).forEach(pokemonData => {
                    const box = document.createElement("div");
                    box.className = "pokemon-box";

                    // Pokemon name
                    const name = document.createElement("div");
                    name.className = "pokemon-name";
                    name.textContent = pokemonData.Species;
                    box.appendChild(name);

                    // Pokemon icon (clickable link to pokemon page)
                    const iconLink = document.createElement("a");
                    iconLink.href = `pokemon.html?name=${encodeURIComponent(pokemonData.Species)}`;
                    iconLink.style.textDecoration = "none";
                    
                    const icon = document.createElement("img");
                    icon.className = "pokemon-icon";
                    icon.src = getPokemonIconPath(pokemonData.Species);
                    icon.alt = pokemonData.Species;
                    let iconFailed = false;
                    icon.onerror = function() {
                        if (!iconFailed) {
                            iconFailed = true;
                            this.src = 'image/icons/unknown.png';
                        } else {
                            this.style.display = 'none';
                        }
                    };
                    iconLink.appendChild(icon);
                    box.appendChild(iconLink);

                    // Show combined percentage
                    const chance = document.createElement("div");
                    chance.className = "pokemon-chance";
                    chance.textContent = `${pokemonData.totalPercent}%`;
                    box.appendChild(chance);

                    grid.appendChild(box);
                });
                
                section.appendChild(grid);
            } else {
                // Display each encounter type with its pokemon
                encounters.forEach((encounter, idx) => {
                    // Calculate level range for this encounter
                    let minLevel = Infinity;
                    let maxLevel = -Infinity;
                    encounter.Slots.forEach(slot => {
                        minLevel = Math.min(minLevel, slot.MinLevel);
                        maxLevel = Math.max(maxLevel, slot.MaxLevel);
                    });
                    
                    // Format level range
                    let levelRange = "";
                    if (minLevel !== Infinity && maxLevel !== -Infinity) {
                        if (minLevel === maxLevel) {
                            levelRange = ` (Lv. ${minLevel})`;
                        } else {
                            levelRange = ` (Lv. ${minLevel}-${maxLevel})`;
                        }
                    }
                    
                    // Show sub-header only if it's different from the main section title
                    // and also different from the previous encounter type
                    const showSubHeader = encounter.EncounterType !== sectionTitle && 
                                         (idx === 0 || encounters[idx - 1].EncounterType !== encounter.EncounterType);
                    
                    if (showSubHeader) {
                        const subHeader = document.createElement("div");
                        subHeader.style.fontSize = "1.1rem";
                        subHeader.style.fontWeight = "600";
                        subHeader.style.marginTop = "15px";
                        subHeader.style.marginBottom = "10px";
                        subHeader.style.color = "#555";
                        subHeader.textContent = encounter.EncounterType + levelRange;
                        section.appendChild(subHeader);
                    }

                    // Combine duplicate Pokemon and sum their chances
                    const pokemonMap = new Map();
                    
                    encounter.Slots.forEach(slot => {
                        const species = slot.Species;
                        if (pokemonMap.has(species)) {
                            const existing = pokemonMap.get(species);
                            // Parse and sum percentages
                            const existingChance = parseFloat(existing.Chance.replace('%', '')) || 0;
                            const newChance = parseFloat(slot.Chance.replace('%', '')) || 0;
                            existing.Chance = `${existingChance + newChance}%`;
                        } else {
                            pokemonMap.set(species, {
                                Species: species,
                                Chance: slot.Chance || ""
                            });
                        }
                    });

                    const grid = document.createElement("div");
                    grid.className = "pokemon-grid";

                    // Convert map to array and display
                    Array.from(pokemonMap.values()).forEach(pokemonData => {
                        const box = document.createElement("div");
                        box.className = "pokemon-box";

                        // Pokemon name
                        const name = document.createElement("div");
                        name.className = "pokemon-name";
                        name.textContent = pokemonData.Species;
                        box.appendChild(name);

                        // Pokemon icon (clickable link to pokemon page)
                        const iconLink = document.createElement("a");
                        iconLink.href = `pokemon.html?name=${encodeURIComponent(pokemonData.Species)}`;
                        iconLink.style.textDecoration = "none";
                        
                        const icon = document.createElement("img");
                        icon.className = "pokemon-icon";
                        icon.src = getPokemonIconPath(pokemonData.Species);
                        icon.alt = pokemonData.Species;
                        let iconFailed = false;
                        icon.onerror = function() {
                            if (!iconFailed) {
                                iconFailed = true;
                                this.src = 'image/icons/unknown.png';
                            } else {
                                // If even the fallback fails, hide the image
                                this.style.display = 'none';
                            }
                        };
                        iconLink.appendChild(icon);
                        box.appendChild(iconLink);

                        // Encounter chance
                        if (pokemonData.Chance) {
                            const chance = document.createElement("div");
                            chance.className = "pokemon-chance";
                            chance.textContent = pokemonData.Chance;
                            box.appendChild(chance);
                        }

                        grid.appendChild(box);
                    });

                    section.appendChild(grid);
                });
            }

        container.appendChild(section);
    }

    loadEncounters();
</script>

</body>
</html>
