
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wild Encounters</title>

    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Standardized header styles & script -->
    <link rel="stylesheet" href="header.css">
    <script src="header.js" defer></script>

    <link rel="stylesheet" href="style.css">
    <style>
        :root {
            --border-thick: 2px;
            --border-color: #6f6f6f;
            --pokemon-border-color: #555555;
            --inner-padding-x: 10px;
            --inner-padding-y: 12px;
            --separator-thick: 4px;
            --sep-color: #e6e6e6;
        }

        body {
            font-family: 'Lexend', sans-serif;
            background: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
        }

        .sidebar {
            position: fixed;
            top: 65px;
            left: 0;
            width: 320px;
            height: calc(100vh - 65px);
            background: white;
            overflow-y: auto;
            box-shadow: 3px 0 8px rgba(0,0,0,0.07);
            padding: 15px;
        }

        .location-tab {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: #f2f2f2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .location-tab:hover {
            background: #e3e3e3;
        }

        .location-tab.active {
            background: #1976d2;
            color: white;
            font-weight: 600;
        }

        .encounters-section {
            padding: 20px;
            max-width: 1600px;
            margin-left: 340px;
            margin-top: 90px;
            width: calc(100% - 340px);
        }

        .location-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .area-title {
            font-size: 1.8rem;
            font-weight: 700;
            flex: 1;
            text-align: center;
        }
        
        .nav-button {
            padding: 10px 20px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background 0.2s;
            min-width: 120px;
        }
        
        .nav-button:hover:not(:disabled) {
            background: #1565c0;
        }
        
        .nav-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .encounter-type-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .encounter-type-header {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #1976d2;
        }

        .items-section {
            background: #6a6a6a;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .pokemon-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }

        .pokemon-box {
            background: #fafafa;
            border: 2px solid var(--pokemon-border-color);
            border-radius: 10px;
            padding: 10px;
            width: 100px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .pokemon-name {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }

        .pokemon-icon {
            width: 60px;
            height: 60px;
            image-rendering: pixelated;
            margin: 5px auto;
            display: block;
        }

        .pokemon-chance {
            font-weight: 600;
            color: #1976d2;
            margin-top: 5px;
        }

        .na-message {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        @media (max-width: 520px) {
            .sidebar {
                display: none;
            }
            .encounters-section { 
                margin-left: 16px; 
                width: calc(100% - 16px); 
            }
            .pokemon-box {
                width: 100%;
            }
        }
    </style>
</head>

<body>

<div class="sidebar" id="sidebar"></div>

<div class="encounters-section" id="encountersSection"></div>

<script>
    let encounterData = [];
    let pokedexData = {};
    let itemsData = [];

    async function loadEncounters() {
        const sidebar = document.getElementById("sidebar");

        try {
            // Fetch encounters, pokedex, and items data
            const [encountersRes, pokedexRes, itemsRes] = await Promise.all([
                fetch("data/encounters.json"),
                fetch("data/pokedex.json"),
                fetch("data/items.json").catch(() => null) // Handle if items.json doesn't exist yet
            ]);
            
            if (!encountersRes.ok || !pokedexRes.ok) {
                throw new Error("Failed to load encounter data");
            }
            
            encounterData = await encountersRes.json();
            pokedexData = await pokedexRes.json();
            
            // Load items data if available
            if (itemsRes && itemsRes.ok) {
                itemsData = await itemsRes.json();
            }
            
            // Terminus Cave entries - keep all as "Terminus Cave" 
            // They will be displayed as separate encounter sections under one location
            // No renaming needed - all 5 LocationIDs (343, 344, 345, 347, 348) stay as "Terminus Cave"
            
            // Define the desired order of locations
            const locationOrder = [
                "Vaniville Town",
                "Route 1",
                "Aquacorde Town",
                "Route 2",
                "Santalune Forest",
                "Route 3",
                "Santalune City",
                "Route 22",
                "Route 4",
                "Lumiose City",
                "Route 5",
                "Camphrier Town",
                "Kalos Hotels",
                "Route 6",
                "Berry Fields",
                "Parfum Palace",
                "Route 7",
                "Connecting Cave",
                "Route 8",
                "Ambrette Town",
                "Route 9",
                "Glittering Cave",
                "Cyllage City",
                "Route 10",
                "Geosenge Town",
                "Route 11",
                "Reflection Cave",
                "Reflection Cave - Floor 1, B Floor 1",
                "Reflection Cave - B Floor 2-3",
                "Shalour City",
                "Tower of Mastery",
                "Route 12",
                "Azure Bay",
                "Coumarine City",
                "Route 13",
                "Kalos Power Plant",
                "Route 14",
                "Laverre City",
                "Poke Ball Factory",
                "Route 15",
                "Route 16",
                "Lost Hotel",
                "Dendemille Town",
                "Frost Cavern",
                "Route 17",
                "Anistar City",
                "Route 18",
                "Terminus Cave",
                "Couriway Town",
                "Route 19",
                "Snowbelle City",
                "Route 20",
                "Pokemon Village",
                "Route 21",
                "Chamber of Emptiness",
                "Victory Road",
                "Victory Road - Room 1 & 2",
                "Victory Road - Room 3 & 4",
                "Victory Road - Outside",
                "Unknown Dungeon",
                "Kiloude City"
            ];
            
            // Reorder encounterData based on locationOrder
            // Group locations by name to handle duplicates (like Terminus Cave)
            const orderedEncounterData = [];
            const encounterMap = new Map();
            
            // Create a map with arrays for locations with same name
            encounterData.forEach(location => {
                if (!encounterMap.has(location.LocationName)) {
                    encounterMap.set(location.LocationName, []);
                }
                encounterMap.get(location.LocationName).push(location);
            });
            
            // Add locations in the specified order
            locationOrder.forEach(locationName => {
                if (encounterMap.has(locationName)) {
                    // Add all instances of this location name
                    orderedEncounterData.push(...encounterMap.get(locationName));
                    encounterMap.delete(locationName);
                }
            });
            
            // Add any remaining locations not in the order list
            encounterMap.forEach(locationsList => {
                orderedEncounterData.push(...locationsList);
            });
            
            // Replace encounterData with ordered version
            encounterData = orderedEncounterData;
        } catch (error) {
            console.error("Error loading encounters:", error);
            sidebar.innerHTML = '<div style="padding: 20px; color: #d32f2f;">Error loading encounter data. Please refresh the page.</div>';
            return;
        }

        // Build sidebar tabs from encounter locations (unique names only)
        const uniqueLocationNames = [];
        const locationNameToIndices = new Map();
        
        encounterData.forEach((location, index) => {
            if (!locationNameToIndices.has(location.LocationName)) {
                uniqueLocationNames.push(location.LocationName);
                locationNameToIndices.set(location.LocationName, []);
            }
            locationNameToIndices.get(location.LocationName).push(index);
        });
        
        uniqueLocationNames.forEach((locationName) => {
            const tab = document.createElement("div");
            tab.className = "location-tab";
            tab.textContent = locationName;
            tab.onclick = () => {
                document.querySelectorAll(".location-tab").forEach(t => t.classList.remove("active"));
                tab.classList.add("active");
                // Display all encounters for this location name
                displayLocationByName(locationName, locationNameToIndices.get(locationName));
            };
            sidebar.appendChild(tab);
        });

        // Activate first tab if present
        if (sidebar.children.length && uniqueLocationNames.length > 0) {
            sidebar.children[0].classList.add("active");
            displayLocationByName(uniqueLocationNames[0], locationNameToIndices.get(uniqueLocationNames[0]));
        }
    }

    function displayLocationByName(locationName, indices) {
        const container = document.getElementById("encountersSection");
        container.innerHTML = "";
        
        // Get navigation info
        const allTabs = Array.from(document.querySelectorAll(".location-tab"));
        const currentTabIndex = allTabs.findIndex(tab => tab.textContent === locationName);
        const hasPrev = currentTabIndex > 0;
        const hasNext = currentTabIndex < allTabs.length - 1;
        
        // Helper function to create navigation buttons
        function createNavigationButtons(includeTitle = true) {
            const navContainer = document.createElement("div");
            navContainer.className = "location-header-container";
            
            // Previous button
            const prevButton = document.createElement("button");
            prevButton.className = "nav-button";
            prevButton.innerHTML = "← " + (hasPrev ? allTabs[currentTabIndex - 1].textContent : "Previous Location");
            prevButton.disabled = !hasPrev;
            if (hasPrev) {
                prevButton.onclick = () => allTabs[currentTabIndex - 1].click();
            }
            navContainer.appendChild(prevButton);
            
            // Title (optional)
            if (includeTitle) {
                const title = document.createElement("h2");
                title.textContent = locationName;
                title.style.margin = "0 20px";
                navContainer.appendChild(title);
            }
            
            // Next button
            const nextButton = document.createElement("button");
            nextButton.className = "nav-button";
            nextButton.innerHTML = (hasNext ? allTabs[currentTabIndex + 1].textContent : "Next Location") + " →";
            nextButton.disabled = !hasNext;
            if (hasNext) {
                nextButton.onclick = () => allTabs[currentTabIndex + 1].click();
            }
            navContainer.appendChild(nextButton);
            
            return navContainer;
        }
        
        // Add navigation at the top
        container.appendChild(createNavigationButtons(true));
        
        // Aggregate all encounters from all LocationIDs for this location name
        const aggregatedEncounters = {
            grass: [],
            fishing: [],
            rockSmash: [],
            surfing: [],
            hordes: []
        };
        
        // Collect all encounters across all indices
        indices.forEach((locationIndex) => {
            const location = encounterData[locationIndex];
            if (!location || !location.Encounters || !Array.isArray(location.Encounters)) return;
            
            location.Encounters.forEach(encounter => {
                const type = encounter.EncounterType.toLowerCase();
                
                if (type.includes('horde')) {
                    aggregatedEncounters.hordes.push(encounter);
                } else if (type.includes('rock smash')) {
                    aggregatedEncounters.rockSmash.push(encounter);
                } else if (type.includes('surf')) {
                    aggregatedEncounters.surfing.push(encounter);
                } else if (type.includes('rod')) {
                    aggregatedEncounters.fishing.push(encounter);
                } else {
                    // Grass, flowers, rough terrain, etc.
                    aggregatedEncounters.grass.push(encounter);
                }
            });
        });
        
        // Display each encounter type section
        displayEncounterSection(container, "Grass / Terrain Encounters", aggregatedEncounters.grass);
        displayEncounterSection(container, "Fishing", aggregatedEncounters.fishing);
        displayEncounterSection(container, "Rock Smash", aggregatedEncounters.rockSmash);
        displayEncounterSection(container, "Surfing", aggregatedEncounters.surfing);
        displayEncounterSection(container, "Horde Encounters", aggregatedEncounters.hordes);
        
        // Display Items section
        displayItemsSection(container, locationName);
        
        // Add navigation buttons at the bottom (without title)
        const footerContainer = createNavigationButtons(false);
        footerContainer.style.marginTop = "30px";
        container.appendChild(footerContainer);
    }

    function normalizeForCompare(s) {
        return (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");
    }

    function findPokedexEntry(pokeName) {
        if (!pokedexData || !pokeName) return null;
        if (pokedexData[pokeName]) return pokedexData[pokeName];
        const target = normalizeForCompare(pokeName);
        for (const key in pokedexData) {
            if (normalizeForCompare(key) === target) return pokedexData[key];
        }
        return null;
    }

    function getPokemonIconPath(pokemonName) {
        // Normalize the pokemon name for the icon filename
        const normalized = pokemonName.toLowerCase().replace(/[^a-z0-9]/g, "");
        return `image/icons/${normalized}.png`;
    }

    function getItemIconPath(itemName) {
        // Convert item name to filename format (lowercase, replace spaces with hyphens)
        const filename = itemName.toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '') // Remove special characters except spaces and hyphens
            .replace(/\s+/g, '-') // Replace spaces with hyphens
            .replace(/-+/g, '-'); // Replace multiple hyphens with single
        return `image/item/${filename}.png`;
    }

    function parseAreaAndSubArea(area) {
        // Extract sub-area from parentheses
        const match = area.match(/^(.+?)\s*\((.+?)\)$/);
        if (match) {
            return {
                mainArea: match[1].trim(),
                subArea: match[2].trim()
            };
        }
        return {
            mainArea: area,
            subArea: ""
        };
    }

    function displayItemsSection(container, locationName) {
        const itemsSection = document.createElement("div");
        itemsSection.className = "items-section";
        itemsSection.style.marginTop = "30px";

        const header = document.createElement("h3");
        header.textContent = "Items";
        header.style.borderBottom = "2px solid #2196F3";
        header.style.paddingBottom = "10px";
        header.style.marginBottom = "20px";
        header.style.color = "#ffffff";
        itemsSection.appendChild(header);

        // Filter items for this location
        const locationItems = itemsData.filter(item => {
            const parsed = parseAreaAndSubArea(item.Area);
            return parsed.mainArea === locationName;
        });

        if (locationItems.length === 0) {
            const noItems = document.createElement("p");
            noItems.textContent = "Items information will be added in a future update.";
            noItems.style.color = "#cccccc";
            noItems.style.textAlign = "center";
            noItems.style.padding = "20px";
            itemsSection.appendChild(noItems);
        } else {
            // Group items by sub-area
            const itemsBySubArea = new Map();
            locationItems.forEach(item => {
                const parsed = parseAreaAndSubArea(item.Area);
                const subArea = parsed.subArea || "General";
                if (!itemsBySubArea.has(subArea)) {
                    itemsBySubArea.set(subArea, []);
                }
                itemsBySubArea.get(subArea).push(item);
            });

            // Display items grouped by sub-area
            itemsBySubArea.forEach((items, subArea) => {
                // Sub-area header (if not "General")
                if (subArea !== "General") {
                    const subAreaHeader = document.createElement("div");
                    subAreaHeader.textContent = subArea;
                    subAreaHeader.style.fontSize = "1.1rem";
                    subAreaHeader.style.fontWeight = "600";
                    subAreaHeader.style.marginTop = "20px";
                    subAreaHeader.style.marginBottom = "10px";
                    subAreaHeader.style.color = "#ffffff";
                    itemsSection.appendChild(subAreaHeader);
                }

                // Create items table
                const table = document.createElement("table");
                table.style.width = "100%";
                table.style.borderCollapse = "collapse";
                table.style.marginBottom = "20px";

                // Table header
                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr style="background-color: #f5f5f5; border-bottom: 2px solid #ddd;">
                        <th style="padding: 10px; text-align: center; width: 60px;">Icon</th>
                        <th style="padding: 10px; text-align: center;">Item</th>
                        <th style="padding: 10px; text-align: center;">Location/Price</th>
                    </tr>
                `;
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement("tbody");
                items.forEach((item, idx) => {
                    const row = document.createElement("tr");
                    row.style.borderBottom = "1px solid #eee";
                    if (idx % 2 === 0) {
                        row.style.backgroundColor = "#fafafa";
                    }

                    // Icon cell
                    const iconCell = document.createElement("td");
                    iconCell.style.padding = "10px";
                    iconCell.style.textAlign = "center";
                    const icon = document.createElement("img");
                    icon.src = getItemIconPath(item.Item);
                    icon.alt = item.Item;
                    icon.style.width = "40px";
                    icon.style.height = "40px";
                    icon.onerror = function() {
                        this.src = 'image/item/unknown.png';
                        this.onerror = function() {
                            this.style.display = 'none';
                        };
                    };
                    iconCell.appendChild(icon);
                    row.appendChild(iconCell);

                    // Item name cell
                    const nameCell = document.createElement("td");
                    nameCell.style.padding = "10px";
                    nameCell.style.fontWeight = "600";
                    nameCell.textContent = item.Item;
                    row.appendChild(nameCell);

                    // Location/Price cell
                    const locationCell = document.createElement("td");
                    locationCell.style.padding = "10px";
                    locationCell.textContent = item["Location/Price"];
                    row.appendChild(locationCell);

                    tbody.appendChild(row);
                });
                table.appendChild(tbody);

                itemsSection.appendChild(table);
            });
        }

        container.appendChild(itemsSection);
    }

    function displayEncounterSection(container, sectionTitle, encounters) {
        // Skip empty encounter sections entirely
        if (encounters.length === 0) {
            return;
        }

        const section = document.createElement("div");
        section.className = "encounter-type-section";

        const header = document.createElement("div");
        header.className = "encounter-type-header";
        header.textContent = sectionTitle;
        section.appendChild(header);

        // Check if this is a horde section - handle specially
        const isHordeSection = sectionTitle.toLowerCase().includes('horde');
        
        if (isHordeSection) {
                // For hordes, combine all Pokemon across all horde types
                const pokemonBySpecies = new Map();
                
                encounters.forEach(encounter => {
                    const hordeMatch = encounter.EncounterType.match(/Horde \((\d+)%\)/);
                    const hordePercent = hordeMatch ? parseInt(hordeMatch[1]) : 0;
                    
                    encounter.Slots.forEach(slot => {
                        const species = slot.Species;
                        if (!pokemonBySpecies.has(species)) {
                            pokemonBySpecies.set(species, {
                                Species: species,
                                hordeTypes: [],
                                totalPercent: 0
                            });
                        }
                        const pokemonData = pokemonBySpecies.get(species);
                        if (!pokemonData.hordeTypes.includes(hordePercent)) {
                            pokemonData.hordeTypes.push(hordePercent);
                            pokemonData.totalPercent += hordePercent;
                        }
                    });
                });
                
                // Display all Pokemon in a single grid under the main header
                const grid = document.createElement("div");
                grid.className = "pokemon-grid";
                
                Array.from(pokemonBySpecies.values()).forEach(pokemonData => {
                    const box = document.createElement("div");
                    box.className = "pokemon-box";

                    // Pokemon name
                    const name = document.createElement("div");
                    name.className = "pokemon-name";
                    name.textContent = pokemonData.Species;
                    box.appendChild(name);

                    // Pokemon icon
                    const icon = document.createElement("img");
                    icon.className = "pokemon-icon";
                    icon.src = getPokemonIconPath(pokemonData.Species);
                    icon.alt = pokemonData.Species;
                    let iconFailed = false;
                    icon.onerror = function() {
                        if (!iconFailed) {
                            iconFailed = true;
                            this.src = 'image/icons/unknown.png';
                        } else {
                            this.style.display = 'none';
                        }
                    };
                    box.appendChild(icon);

                    // Show combined percentage
                    const chance = document.createElement("div");
                    chance.className = "pokemon-chance";
                    chance.textContent = `${pokemonData.totalPercent}%`;
                    box.appendChild(chance);

                    grid.appendChild(box);
                });
                
                section.appendChild(grid);
            } else {
                // Display each encounter type with its pokemon
                encounters.forEach((encounter, idx) => {
                    // Calculate level range for this encounter
                    let minLevel = Infinity;
                    let maxLevel = -Infinity;
                    encounter.Slots.forEach(slot => {
                        minLevel = Math.min(minLevel, slot.MinLevel);
                        maxLevel = Math.max(maxLevel, slot.MaxLevel);
                    });
                    
                    // Format level range
                    let levelRange = "";
                    if (minLevel !== Infinity && maxLevel !== -Infinity) {
                        if (minLevel === maxLevel) {
                            levelRange = ` (Lv. ${minLevel})`;
                        } else {
                            levelRange = ` (Lv. ${minLevel}-${maxLevel})`;
                        }
                    }
                    
                    // Show sub-header only if it's different from the main section title
                    // and also different from the previous encounter type
                    const showSubHeader = encounter.EncounterType !== sectionTitle && 
                                         (idx === 0 || encounters[idx - 1].EncounterType !== encounter.EncounterType);
                    
                    if (showSubHeader) {
                        const subHeader = document.createElement("div");
                        subHeader.style.fontSize = "1.1rem";
                        subHeader.style.fontWeight = "600";
                        subHeader.style.marginTop = "15px";
                        subHeader.style.marginBottom = "10px";
                        subHeader.style.color = "#555";
                        subHeader.textContent = encounter.EncounterType + levelRange;
                        section.appendChild(subHeader);
                    }

                    // Combine duplicate Pokemon and sum their chances
                    const pokemonMap = new Map();
                    
                    encounter.Slots.forEach(slot => {
                        const species = slot.Species;
                        if (pokemonMap.has(species)) {
                            const existing = pokemonMap.get(species);
                            // Parse and sum percentages
                            const existingChance = parseFloat(existing.Chance.replace('%', '')) || 0;
                            const newChance = parseFloat(slot.Chance.replace('%', '')) || 0;
                            existing.Chance = `${existingChance + newChance}%`;
                        } else {
                            pokemonMap.set(species, {
                                Species: species,
                                Chance: slot.Chance || ""
                            });
                        }
                    });

                    const grid = document.createElement("div");
                    grid.className = "pokemon-grid";

                    // Convert map to array and display
                    Array.from(pokemonMap.values()).forEach(pokemonData => {
                        const box = document.createElement("div");
                        box.className = "pokemon-box";

                        // Pokemon name
                        const name = document.createElement("div");
                        name.className = "pokemon-name";
                        name.textContent = pokemonData.Species;
                        box.appendChild(name);

                        // Pokemon icon
                        const icon = document.createElement("img");
                        icon.className = "pokemon-icon";
                        icon.src = getPokemonIconPath(pokemonData.Species);
                        icon.alt = pokemonData.Species;
                        let iconFailed = false;
                        icon.onerror = function() {
                            if (!iconFailed) {
                                iconFailed = true;
                                this.src = 'image/icons/unknown.png';
                            } else {
                                // If even the fallback fails, hide the image
                                this.style.display = 'none';
                            }
                        };
                        box.appendChild(icon);

                        // Encounter chance
                        if (pokemonData.Chance) {
                            const chance = document.createElement("div");
                            chance.className = "pokemon-chance";
                            chance.textContent = pokemonData.Chance;
                            box.appendChild(chance);
                        }

                        grid.appendChild(box);
                    });

                    section.appendChild(grid);
                });
            }

        container.appendChild(section);
    }

    loadEncounters();
</script>

</body>
</html>
