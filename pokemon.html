<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pokémon Stats</title>
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;600&display=swap" rel="stylesheet">

<!-- Standardized header styles & script -->
<link rel="stylesheet" href="header.css">
<script src="header.js" defer></script>

<style>
  body { font-family:"Lexend", sans-serif; background:#f0f0f0; margin:0; padding:80px 20px 20px 20px; }
  a.back { color:#4285F4; text-decoration:none; display:inline-block; margin-bottom:20px; }
  h1 { text-align:center; margin-bottom:10px; }
  .card { background:white; padding:20px; border-radius:15px; box-shadow:0 3px 8px rgba(0,0,0,0.15); max-width:1200px; margin:auto; position:relative; }

  .section { margin-bottom:25px; background:#fafafa; padding:15px 20px; border-radius:12px; box-shadow:0 1px 4px rgba(0,0,0,0.1); }
  .section h2 { margin-top:0; border-bottom:1px solid #ddd; padding-bottom:5px; margin-bottom:10px; }

  .sprite { display:block; margin:10px auto; width:128px; height:128px; image-rendering:pixelated; }
  .types { text-align:center; margin-bottom:10px; }
  .type { display:inline-block; padding:4px 10px; border-radius:12px; font-size:0.85em; color:white; margin:3px; }

  .nav-btn { position:absolute; top:20px; padding:10px 20px; background:#4285F4; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:600; font-size:14px; transition: background 0.2s; }
  .prev-btn { left:20px; }
  .next-btn { right:20px; }
  .nav-btn:hover { background:#3367d6; }
  .nav-btn:active { transform: scale(0.98); }

  ul { list-style:none; padding-left:0; margin:0 0 10px 0; }
  .label { font-weight:bold; margin-top:10px; margin-bottom:3px; }

  /* Type Colors */
  .type-grass { background: #63bb5b; }
  .type-poison { background: #aa5caf; }
  .type-fire { background: #ff9c54; }
  .type-water { background: #4f90d9; }
  .type-normal { background: #9099a1; }
  .type-electric { background: #f3d23b; }
  .type-ice { background: #74cec0; }
  .type-fighting { background: #ce4069; }
  .type-ground { background: #d97746; }
  .type-flying { background: #92aade; }
  .type-psychic { background: #f97176; }
  .type-bug { background: #90c12c; }
  .type-rock { background: #c7b78b; }
  .type-ghost { background: #5269ac; }
  .type-dark { background: #5a5366; }
  .type-dragon { background: #096dc4; }
  .type-steel { background: #5a8ea2; }
  .type-fairy { background: #ec8fe6; }

  /* Evolution Styles */
  #evolution-chain { display:flex; align-items:center; justify-content:center; gap:30px; flex-wrap:wrap; margin-top:20px; min-height:200px; }
  .evo-stage { display:flex; align-items:center; gap:30px; }
  .evo-block { text-align:center; }
  .evo-img { width:120px; height:120px; image-rendering:pixelated; display:block; margin:0 auto 5px; }
  .evo-name { font-weight:bold; font-size:18px; }
  .evo-arrow-block { text-align:center; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:80px; }
  .method-text { font-size:13px; font-weight:600; text-decoration:underline; margin-bottom:8px; }
  .arrow { font-size:48px; font-weight:900; color:#4285F4; }
  
  /* Branching evolution styles */
  .branch-container { display:flex; flex-direction:row; align-items:center; gap:15px; position:relative; }
  .branch-column { display:flex; flex-direction:column; align-items:flex-start; gap:40px; }
  .pre-evo-centered { display:flex; align-items:center; gap:30px; }
  
  /* Diagonal arrow styling for branches */
  .diagonal-arrow { position:relative; display:flex; align-items:center; justify-content:center; width:100px; height:60px; }
  .diagonal-arrow .arrow { font-size:48px; font-weight:900; color:#4285F4; transform:rotate(-45deg); }
  .diagonal-arrow.down .arrow { transform:rotate(45deg); }
  
  /* Eevee circular layout */
  .eevee-circle { position:relative; width:800px; height:800px; margin:20px auto; }
  .eevee-center { position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10; }
  .eevee-evo { position:absolute; }
  .eevee-evo .evo-block { position:relative; }
  .eevee-evo .method-text { position:absolute; top:-30px; left:50%; transform:translateX(-50%); white-space:nowrap; font-size:13px; font-weight:600; }
  .eevee-arrow { position:absolute; font-size:36px; font-weight:900; color:#4285F4; }

  /* Horizontal centering for multi-branch */
  .multi-branch-container { display:flex; flex-direction:row; align-items:flex-start; gap:50px; }
  .branch-group { display:flex; flex-direction:column; align-items:center; gap:25px; }

  /* Moves Table */
  .moves-section {
      display:flex;
      gap:20px;
      flex-wrap:wrap;
  }
  .moves-table {
      width:100%;
      border-collapse: collapse;
      margin-top:10px;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      font-size:0.85em;
  }
  .moves-table th, .moves-table td {
      padding:6px 8px;
      border-bottom:1px solid #ddd;
      text-align:left;
  }
  .moves-table th { background:#f5f5f5; font-weight:600; }
  .moves-table tr:hover { background:#f0f0f0; }
  .category-icon { width:24px; height:24px; display:block; margin:0 auto; }
  .moves-table-container { flex:1; min-width:280px; }

  /* center the Cat column header and images under it */
  .moves-table th.cat, .moves-table td.cat { text-align:center; }
  .moves-table th.cat { vertical-align:middle; }

  /* ⭐ Base Stats Bars */
  .stat-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 3px 0;
  }
  .stat-name {
      width: 35px;
      font-weight: bold;
      text-align: right;
  }
  .stat-num {
      width: 30px;
      text-align: left;
      font-size: 0.9em;
  }
  .stat-bar-bg {
      flex-grow: 1;
      height: 8px;
      border-radius: 4px;
      background: #ddd;
      overflow: hidden;
  }
  .stat-bar-fill {
      height: 100%;
      border-radius: 4px;
  }

  /* Info section columns - make 4 equal width and evenly spaced */
  .info .info-cols {
    display:flex;
    gap:20px;
    justify-content:space-between;
    align-items:flex-start;
    flex-wrap:wrap;
  }
  .info .info-cols > div {
    flex:1;
    min-width:180px;
    text-align:center;
  }
  .info .info-cols h3 { margin:0 0 8px 0; text-decoration:underline; }

  /* Larger tooltip font size for abilities */
  [title] {
    cursor: help;
  }
  
  /* Override browser default tooltip styling with larger font */
  @supports (font-size: 16px) {
    [title]:hover::after {
      font-size: 16px;
    }
  }

  /* Alternate Forms Tabs */
  .form-tabs {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin: 20px 0 15px 0;
    flex-wrap: wrap;
  }
  .form-tab {
    padding: 8px 16px;
    background: #e0e0e0;
    border: 2px solid #ccc;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s;
    user-select: none;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .form-tab:hover {
    background: #d0d0d0;
    transform: translateY(-1px);
  }
  .form-tab.active {
    background: #4285F4;
    color: white;
    border-color: #3367d6;
    cursor: default;
  }
  .form-tab.active:hover {
    transform: none;
  }
  .form-tab-icon {
    width: 24px;
    height: 24px;
    object-fit: contain;
    image-rendering: pixelated;
  }

</style>
</head>
<body>

<a class="back" href="index.html">← Back to Pokédex</a>
<div id="pokemonCard" class="card">Loading…</div>

<script>
const typeColors = {
  Normal:"#9099a1", Fire:"#ff9c54", Water:"#4f90d9", Electric:"#f3d23b",
  Grass:"#63bb5b", Ice:"#74cec0", Fighting:"#ce4069", Poison:"#aa5caf",
  Ground:"#d97746", Flying:"#92aade", Psychic:"#f97176", Bug:"#90c12c",
  Rock:"#c7b78b", Ghost:"#5269ac", Dragon:"#096dc4", Dark:"#5a5366",
  Steel:"#5a8ea2", Fairy:"#ec8fe6"
};

const urlParams = new URLSearchParams(window.location.search);
const monName = urlParams.get("name");
const formParam = urlParams.get("form"); // Optional form parameter

// --- Multi-folder sprite support ---
const spriteFolders = ["pokemon_sprites", "pokemon_sprties2"];
function getPokemonImage(name) {
    const spriteName = name.toLowerCase().replace(/\s+/g, '-');
    return new Promise(resolve => {
        let index = 0;
        function tryNext() {
            if(index >= spriteFolders.length){
                resolve('pokemon_sprites_unknown/unknown.png');
                return;
            }
            const url = `${spriteFolders[index]}/${spriteName}.png`;
            const img = new Image();
            img.onload = () => resolve(url);
            img.onerror = () => { index++; tryNext(); };
            img.src = url;
        }
        tryNext();
    });
}

// Fetch data
Promise.all([
  fetch('data/pokedex.json').then(r => r.json()),
  fetch('data/movesets.json').then(r => r.json()),
  fetch('data/moves.json').then(r => r.json()),
  fetch('data/evolutions.json').then(r => r.json()),
  fetch('data/encounters.json').then(r => r.json()),
  fetch('data/basegamestats.json').then(r => r.json()),
  fetch('data/abilities.json').then(r => r.json())
])
.then(async ([pokedexData, movesetsData, movesData, evolutionsData, encountersData, baseGameStatsData, abilitiesData]) => {

  const mon = pokedexData[monName];
  if (!mon) { document.getElementById("pokemonCard").textContent = "Pokémon not found."; return; }

  // ===== DETECT ALTERNATE FORMS =====
  // Find all forms with the same base name (excluding Nidoran)
  const isNidoran = monName.startsWith('Nidoran');
  let baseFormName = monName;
  let alternateForms = [monName]; // Start with current form
  
  if (!isNidoran) {
    // Extract base name (before first dash)
    baseFormName = monName.includes('-') ? monName.split('-')[0] : monName;
    
    // Find all forms with same base (including base form itself)
    alternateForms = Object.keys(pokedexData).filter(name => {
      if (name.startsWith('Nidoran')) return false;
      const base = name.includes('-') ? name.split('-')[0] : name;
      return base === baseFormName;
    }).sort(); // Sort to ensure consistent order
  }
  
  // Keep track of currently displayed form
  let currentFormName = monName;
  let currentFormData = mon;
  
  // Helper function to check if a Pokemon is an alternate form (has '-' but not Nidoran)
  function isAlternateForm(name) {
    if (name.startsWith('Nidoran')) return false;
    return name.includes('-');
  }
  
  // Helper function to get next base form Pokemon (skip alternate forms)
  function getNextBasePokemon(currentName, sortedNames) {
    const currentIndex = sortedNames.indexOf(currentName);
    for (let i = 1; i < sortedNames.length; i++) {
      const nextIndex = (currentIndex + i) % sortedNames.length;
      const nextName = sortedNames[nextIndex];
      if (!isAlternateForm(nextName)) {
        return nextName;
      }
    }
    return sortedNames[(currentIndex + 1) % sortedNames.length]; // Fallback
  }
  
  // Helper function to get previous base form Pokemon (skip alternate forms)
  function getPrevBasePokemon(currentName, sortedNames) {
    const currentIndex = sortedNames.indexOf(currentName);
    for (let i = 1; i < sortedNames.length; i++) {
      const prevIndex = (currentIndex - i + sortedNames.length) % sortedNames.length;
      const prevName = sortedNames[prevIndex];
      if (!isAlternateForm(prevName)) {
        return prevName;
      }
    }
    return sortedNames[(currentIndex - 1 + sortedNames.length) % sortedNames.length]; // Fallback
  }
  
  const sortedMonNames = Object.entries(pokedexData).sort((a,b)=>a[1].SpeciesIdx-b[1].SpeciesIdx).map(([name])=>name);
  const prevMon = getPrevBasePokemon(monName, sortedMonNames);
  const nextMon = getNextBasePokemon(monName, sortedMonNames);
  const prevMonData = pokedexData[prevMon];
  const nextMonData = pokedexData[nextMon];

  const types = [mon.Type1, mon.Type2].filter((t,i,a)=>t && a.indexOf(t)===i);

  // --- Use multi-folder system ---
  const spriteUrl = await getPokemonImage(monName);

  const bst = mon.BST ?? (mon.BaseStats.HP+mon.BaseStats.Atk+mon.BaseStats.Def+mon.BaseStats.SpA+mon.BaseStats.SpD+mon.BaseStats.Spe);

  // Extract unique locations where this Pokemon can be found
  // Parse the hierarchical encounters.json structure
  const locationSet = new Set();
  encountersData.forEach(locationData => {
    const locationName = locationData.LocationName;
    const encounterTypes = locationData.Encounters || [];
    
    encounterTypes.forEach(encounterType => {
      const slots = encounterType.Slots || [];
      slots.forEach(slot => {
        if (slot.Species === monName) {
          locationSet.add(locationName);
        }
      });
    });
  });
  const locations = Array.from(locationSet).sort();

  // Calculate stat changes compared to base game
  const baseGameMon = baseGameStatsData[monName];
  let statChanges = [];
  let bstChange = 0;
  
  if (baseGameMon && baseGameMon.BaseStats) {
    const stats = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
    const statLabels = {'HP': 'HP', 'Atk': 'Atk', 'Def': 'Def', 'SpA': 'SpA', 'SpD': 'SpD', 'Spe': 'Spe'};
    
    stats.forEach(stat => {
      const currentVal = mon.BaseStats[stat];
      const baseVal = baseGameMon.BaseStats[stat];
      const diff = currentVal - baseVal;
      
      if (diff !== 0) {
        const color = diff > 0 ? '#28a745' : '#dc3545';  // green for positive, red for negative
        const sign = diff > 0 ? '+' : '';
        statChanges.push(`<span style="color:${color}; font-weight:600;">${statLabels[stat]} (${sign}${diff})</span>`);
        bstChange += diff;
      }
    });
    
    if (bstChange !== 0) {
      const color = bstChange > 0 ? '#28a745' : '#dc3545';
      const sign = bstChange > 0 ? '+' : '';
      statChanges.push(`<span style="color:${color}; font-weight:600;">BST (${sign}${bstChange})</span>`);
    }
  }

  const moveList = movesetsData[monName] || [];

  const categoryIcons = { "Physical":"image/physical.png", "Special":"image/special.png", "Status":"image/status.png" };

  const cardDiv = document.getElementById("pokemonCard");

  /* ⭐ Helper for stat bars */
  function createStatRow(label, value, min, max, color) {
      const pct = Math.max(3, Math.min(100, (value - min) / (max - min) * 100));
      return `
          <div class="stat-row">
              <div class="stat-name">${label}</div>
              <div class="stat-num">${value}</div>
              <div class="stat-bar-bg">
                  <div class="stat-bar-fill" style="width:${pct}%; background:${color};"></div>
              </div>
          </div>
      `;
  }

  const statColors = {
      HP: "#FF5959", Atk: "#F5AC78", Def: "#FAE078",
      SpA: "#9DB7F5", SpD: "#A7DB8D", Spe: "#FA92B2", BST: "#B88CFF"
  };

  // Helper function to find ability entry and get tooltip
  function findAbilityEntry(abilityName) {
    if (!abilitiesData || !abilityName || abilityName === "---") return null;
    // Try direct lookup first
    if (abilitiesData[abilityName]) return abilitiesData[abilityName];
    // Try normalized lookup
    const normalizeForCompare = (s) => (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");
    const target = normalizeForCompare(abilityName);
    for (const key in abilitiesData) {
      if (normalizeForCompare(key) === target) return abilitiesData[key];
    }
    return null;
  }

  // Build ability HTML with tooltips
  function formatAbilityWithTooltip(abilityName) {
    if (!abilityName || abilityName === "---") return "";
    const abilityEntry = findAbilityEntry(abilityName);
    const abilityTooltip = abilityEntry ? abilityEntry.shortDesc : "";
    return abilityTooltip 
      ? `<span title="${abilityTooltip}">${abilityName}</span>`
      : abilityName;
  }

  // Helper to format form name for tab display
  function formatFormName(fullName) {
    if (fullName === baseFormName) return "Base";
    // Remove base name and leading dash
    const formSuffix = fullName.substring(baseFormName.length + 1);
    // Convert "Mega-X" to "Mega X", etc.
    return formSuffix.replace(/-/g, ' ');
  }

  // Function to update form-specific data (types, abilities, stats, sprite)
  // Make it globally accessible via window
  window.updateFormData = async function(formName) {
    currentFormName = formName;
    currentFormData = pokedexData[formName];
    
    const formTypes = [currentFormData.Type1, currentFormData.Type2].filter((t,i,a)=>t && a.indexOf(t)===i);
    const formBst = currentFormData.BST ?? (currentFormData.BaseStats.HP+currentFormData.BaseStats.Atk+currentFormData.BaseStats.Def+currentFormData.BaseStats.SpA+currentFormData.BaseStats.SpD+currentFormData.BaseStats.Spe);
    const formSpriteUrl = await getPokemonImage(formName);
    
    // Calculate stat changes for this form
    const baseGameFormData = baseGameStatsData[formName];
    let formStatChanges = [];
    let formBstChange = 0;
    
    if (baseGameFormData && baseGameFormData.BaseStats) {
      const stats = ['HP', 'Atk', 'Def', 'SpA', 'SpD', 'Spe'];
      const statLabels = {'HP': 'HP', 'Atk': 'Atk', 'Def': 'Def', 'SpA': 'SpA', 'SpD': 'SpD', 'Spe': 'Spe'};
      
      stats.forEach(stat => {
        const currentVal = currentFormData.BaseStats[stat];
        const baseVal = baseGameFormData.BaseStats[stat];
        const diff = currentVal - baseVal;
        
        if (diff !== 0) {
          const color = diff > 0 ? '#28a745' : '#dc3545';
          const sign = diff > 0 ? '+' : '';
          formStatChanges.push(`<span style="color:${color}; font-weight:600;">${statLabels[stat]} (${sign}${diff})</span>`);
          formBstChange += diff;
        }
      });
      
      if (formBstChange !== 0) {
        const color = formBstChange > 0 ? '#28a745' : '#dc3545';
        const sign = formBstChange > 0 ? '+' : '';
        formStatChanges.push(`<span style="color:${color}; font-weight:600;">BST (${sign}${formBstChange})</span>`);
      }
    }
    
    // Update sprite
    document.querySelector('.sprite').src = formSpriteUrl;
    
    // Update types
    document.querySelector('.types').innerHTML = formTypes.map(t=>`<span class="type" style="background:${typeColors[t]}">${t}</span>`).join("");
    
    // Update abilities
    const abilitiesUl = document.querySelector('.info-cols div:nth-child(2) ul');
    abilitiesUl.innerHTML = `
      <li>${formatAbilityWithTooltip(currentFormData.Ability1)}</li>
      ${currentFormData.Ability2 ? `<li>${formatAbilityWithTooltip(currentFormData.Ability2)}</li>` : ""}
      <li style="list-style:none; margin-left:-20px; padding-left:20px;">(H): ${formatAbilityWithTooltip(currentFormData.AbilityH)}</li>
    `;
    
    // Update base stats (use same ranges as initial display for consistency)
    const statsContainer = document.querySelector('.base-stats-container');
    statsContainer.innerHTML = `
      ${createStatRow('HP', currentFormData.BaseStats.HP, 15, 180, statColors.HP)}
      ${createStatRow('Atk', currentFormData.BaseStats.Atk, 15, 180, statColors.Atk)}
      ${createStatRow('Def', currentFormData.BaseStats.Def, 15, 180, statColors.Def)}
      ${createStatRow('SpA', currentFormData.BaseStats.SpA, 15, 180, statColors.SpA)}
      ${createStatRow('SpD', currentFormData.BaseStats.SpD, 15, 180, statColors.SpD)}
      ${createStatRow('Spe', currentFormData.BaseStats.Spe, 15, 180, statColors.Spe)}
      ${createStatRow('BST', formBst, 250, 600, statColors.BST)}
    `;
    
    // Update stat changes
    const statChangesDiv = document.querySelector('.stat-changes-content');
    if (formStatChanges.length > 0) {
      statChangesDiv.innerHTML = formStatChanges.map(change => `<div>${change}</div>`).join('');
    } else {
      statChangesDiv.textContent = 'No changes from base game';
    }
    
    // Update active tab
    document.querySelectorAll('.form-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.formName === formName);
    });
  }

  // --- Everything else unchanged, with requested layout changes ---
  cardDiv.innerHTML = `
    <button class="nav-btn prev-btn" onclick="location.href='pokemon.html?name=${encodeURIComponent(prevMon)}'">
      ← #${String(prevMonData.SpeciesIdx).padStart(3,"0")} ${prevMon}
    </button>
    <button class="nav-btn next-btn" onclick="location.href='pokemon.html?name=${encodeURIComponent(nextMon)}'">
      #${String(nextMonData.SpeciesIdx).padStart(3,"0")} ${nextMon} →
    </button>

    <h1>#${String(mon.SpeciesIdx).padStart(3,"0")} ${monName}</h1>
    <img class="sprite" src="${spriteUrl}" onerror="this.src='pokemon_sprites_unknown/unknown.png'">

    <!-- Alternate Forms Tabs (only show if there are multiple forms) -->
    ${alternateForms.length > 1 ? `
      <div class="form-tabs">
        ${alternateForms.map(formName => {
          const iconName = formName.toLowerCase().replace(/\s+/g, '-');
          return `
          <div class="form-tab ${formName === monName ? 'active' : ''}" data-form-name="${formName}" onclick="updateFormData('${formName}')">
            <img src="image/icons/${iconName}.png" alt="" class="form-tab-icon" onerror="this.style.display='none'">
            <span>${formatFormName(formName)}</span>
          </div>
        `;
        }).join('')}
      </div>
    ` : ''}

   <!-- Info / Type / Abilities / Location / Additional Info -->
   <div class="section info">
     <h2>Info</h2>
     <div class="info-cols">
       <div>
         <h3>Type</h3>
         <div class="types">
           ${types.map(t=>`<span class="type" style="background:${typeColors[t]}">${t}</span>`).join("")}
         </div>
       </div>

       <div>
         <h3>Abilities</h3>
         <ul style="text-align:left; display:inline-block; list-style:disc; padding-left:20px;">
           <li>${formatAbilityWithTooltip(mon.Ability1)}</li>
           ${mon.Ability2 ? `<li>${formatAbilityWithTooltip(mon.Ability2)}</li>` : ""}
           <li style="list-style:none; margin-left:-20px; padding-left:20px;">(H): ${formatAbilityWithTooltip(mon.AbilityH)}</li>
         </ul>
       </div>

       <div>
         <h3>Location</h3>
         <ul style="text-align:center; display:inline-block; padding-left:0; margin:0; list-style:none;">
           ${locations.length > 0 ? locations.map(loc => `<li>${loc}</li>`).join('') : '<li>N/A</li>'}
         </ul>
       </div>

       <div>
         <h3>Additional Info</h3>
         <p style="margin:2px 0;" data-height>${mon.Height || 'N/A'} m</p>
         <p style="margin:2px 0;" data-weight>${mon.Weight || 'N/A'} kg</p>
       </div>
     </div>
   </div>

  <!-- Base Stats -->
<div class="section stats">
  <h2>Base Stats</h2>
  <div style="display:flex; gap:20px; flex-wrap:wrap;">
    <div style="flex:1; min-width:200px; text-align:center;">
      <h3 style="text-decoration:underline;">Updated stats</h3>
      <div class="base-stats-container" style="text-align:left; margin-top:10px;">
        ${createStatRow("HP", mon.BaseStats.HP, 15, 180, statColors.HP)}
        ${createStatRow("Atk", mon.BaseStats.Atk, 15, 180, statColors.Atk)}
        ${createStatRow("Def", mon.BaseStats.Def, 15, 180, statColors.Def)}
        ${createStatRow("SpA", mon.BaseStats.SpA, 15, 180, statColors.SpA)}
        ${createStatRow("SpD", mon.BaseStats.SpD, 15, 180, statColors.SpD)}
        ${createStatRow("Spe", mon.BaseStats.Spe, 15, 180, statColors.Spe)}
        ${createStatRow("BST", bst, 250, 600, statColors.BST)}
      </div>
    </div>

    <div style="flex:1; min-width:200px; text-align:center;">
      <h3 style="text-decoration:underline;">Stat Changes</h3>
      <div class="stat-changes-content" style="text-align:center; margin-top:10px;">
        ${statChanges.length > 0 ? statChanges.map(change => `<div>${change}</div>`).join('') : '<p style="margin:0;">No changes from base game</p>'}
      </div>
    </div>
  </div>
</div>

   <!-- Evolutions -->
   <div class="section evolutions">
     <h2>Evolutions</h2>
     <div id="evolution-chain"></div>
   </div>

   <!-- Moves -->
   <div class="section moves">
     <h2>Moves</h2>
     <div style="display:flex; gap:20px; flex-wrap:wrap; margin-top:10px;">
       <div style="flex:1; min-width:200px;">
         <table class="moves-table">
           <thead>
             <tr>
               <th style="text-align:left; width:40px;">Lvl</th>
               <th style="text-align:left; width:120px;">Move</th>
               <th style="text-align:left; width:60px;">Type</th>
               <th class="cat" style="text-align:center; width:40px;">Cat</th>
               <th style="text-align:left; width:40px;">Pow</th>
               <th style="text-align:left; width:40px;">Acc</th>
             </tr>
           </thead>
           <tbody>
             ${moveList.map(m => {
               const mv = movesData[m.Move];
               if (!mv) {
                 console.warn(`Move data not found for: ${m.Move}`);
                 return `<tr>
                   <td>${m.Level}</td>
                   <td>${m.Move}</td>
                   <td><span class="type type-unknown">Unknown</span></td>
                   <td class="cat">—</td>
                   <td>—</td>
                   <td>—</td>
                 </tr>`;
               }
               return `<tr>
                 <td>${m.Level}</td>
                 <td>${m.Move}</td>
                 <td><span class="type type-${mv.Type.toLowerCase()}">${mv.Type}</span></td>
                 <td class="cat"><img class="category-icon" src="${categoryIcons[mv.Category]}"></td>
                 <td>${mv.Power ?? "—"}</td>
                 <td>${mv.Acc ?? "—"}%</td>
               </tr>`;
             }).join("")}
           </tbody>
         </table>
       </div>

       <div style="flex:1; min-width:200px;">
         <table class="moves-table">
           <thead>
             <tr>
               <th style="text-align:left; width:120px;">TM/HM/Tutor</th>
               <th style="text-align:left; width:60px;">Type</th>
               <th class="cat" style="text-align:center; width:40px;">Cat</th>
               <th style="text-align:left; width:40px;">Pow</th>
               <th style="text-align:left; width:40px;">Acc</th>
             </tr>
           </thead>
           <tbody>
             ${mon.TMs ? mon.TMs.map(tm => {
               const mv = movesData[tm.Move];
               return `<tr>
                 <td>${tm.Label}: ${tm.Move}</td>
                 <td><span class="type type-${mv.Type.toLowerCase()}">${mv.Type}</span></td>
                 <td class="cat"><img class="category-icon" src="${categoryIcons[mv.Category]}"></td>
                 <td>${mv.Power ?? "—"}</td>
                 <td>${mv.Acc ?? "—"}%</td>
               </tr>`;
             }).join("") : "<tr><td colspan='5'>No TMs/HMs/Tutor moves</td></tr>"}
           </tbody>
         </table>
       </div>
     </div>
   </div>
  `;

  loadEvolutions(monName, evolutionsData);
  
  // If form parameter is provided, automatically switch to that form
  if (formParam && alternateForms.includes(formParam)) {
    updateFormData(formParam);
  }
});

// evolution renderer with diagonal branching and Eevee circular layout
function loadEvolutions(currentName, data) {
    const evoContainer = document.getElementById("evolution-chain");
    if (!data[currentName]) { evoContainer.innerHTML = "<p>No evolution data available.</p>"; return; }

    // Find the base of the evolution chain
    let pointer = currentName;
    while (data[pointer] && data[pointer].EvolvesFrom) pointer = data[pointer].EvolvesFrom;

    const rendered = new Set();

    const renderEvo = async (name) => {
        if(rendered.has(name)) return "";
        rendered.add(name);

        const imgSrc = await getPokemonImage(name);
        return `
            <div class="evo-block">
              <a href="pokemon.html?name=${encodeURIComponent(name)}" style="text-decoration:none; color:inherit;">
                <img src="${imgSrc}" class="evo-img" onerror="this.src='pokemon_sprites_unknown/unknown.png'">
                <div class="evo-name">${name}</div>
              </a>
            </div>
        `;
    };

    const renderArrow = (method, diagonal = false, direction = "") => {
        if (diagonal) {
            return `
              <div class="diagonal-arrow ${direction}">
                <div class="method-text">${method}</div>
                <div class="arrow">→</div>
              </div>
            `;
        }
        return `
          <div class="evo-arrow-block">
            <div class="method-text">${method}</div>
            <div class="arrow">→</div>
          </div>
        `;
    };

    // Special Eevee circular layout
    const renderEeveeCircle = async (name) => {
        const evolvesInto = data[name].EvolvesInto || {};
        const keys = Object.keys(evolvesInto);
        
        if (keys.length < 6) return null; // Not Eevee's special case
        
        const centerEvo = await renderEvo(name);
        const angleStep = (2 * Math.PI) / keys.length;
        const radius = 300; // Increased from 220 for more spread
        
        let html = `<div class="eevee-circle">`;
        html += `<div class="eevee-center">${centerEvo}</div>`;
        
        for (let i = 0; i < keys.length; i++) {
            const evoName = keys[i];
            const method = evolvesInto[evoName];
            const angle = i * angleStep - Math.PI / 2; // Start at top
            const x = 400 + radius * Math.cos(angle) - 60; // Center and offset for block width
            const y = 400 + radius * Math.sin(angle) - 60; // Center and offset for block height
            
            const evoBlock = await renderEvo(evoName);
            html += `<div class="eevee-evo" style="left:${x}px; top:${y}px;">`;
            html += `<div class="method-text">${method}</div>`;
            html += evoBlock;
            html += `</div>`;
            
            // Add arrow from center to evolution
            const arrowX = 400 + (radius * 0.5) * Math.cos(angle) - 18;
            const arrowY = 400 + (radius * 0.5) * Math.sin(angle) - 24;
            const rotation = (angle * 180 / Math.PI) + 90;
            html += `<div class="eevee-arrow" style="left:${arrowX}px; top:${arrowY}px; transform:rotate(${rotation}deg);">→</div>`;
        }
        
        html += `</div>`;
        return html;
    };

    const buildChain = async (name) => {
        const evolvesInto = data[name].EvolvesInto || {};
        const keys = Object.keys(evolvesInto);
        
        // Check for Eevee special case
        if (name.toLowerCase() === 'eevee' && keys.length >= 6) {
            return await renderEeveeCircle(name);
        }
        
        let html = await renderEvo(name);
        
        if(keys.length === 0) {
            // No more evolutions
            return html;
        } else if(keys.length === 1) {
            // Single evolution path
            const nextName = keys[0];
            const method = evolvesInto[nextName];
            html += renderArrow(method);
            html += await buildChain(nextName);
            return html;
        } else if(keys.length === 2) {
            // Two-way branch - branches on same horizontal line, just shifted up/down
            const branch1Name = keys[0];
            const branch2Name = keys[1];
            const method1 = evolvesInto[branch1Name];
            const method2 = evolvesInto[branch2Name];
            
            const branch1Evo = await renderEvo(branch1Name);
            const branch2Evo = await renderEvo(branch2Name);
            const branch1Rest = await buildChain(branch1Name);
            const branch2Rest = await buildChain(branch2Name);
            
            html = `
              <div class="branch-container">
                <div class="pre-evo-centered">
                  ${html}
                </div>
                <div class="branch-column">
                  <div style="display:flex; align-items:center; gap:15px;">
                    <div class="diagonal-arrow up">
                      <div class="arrow">→</div>
                    </div>
                    <div style="position:relative;">
                      <div style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); font-size:13px; font-weight:600; text-decoration:underline; white-space:nowrap;">${method1}</div>
                      ${branch1Evo}
                    </div>
                    ${branch1Rest !== branch1Evo ? branch1Rest.replace(branch1Evo, '') : ''}
                  </div>
                  <div style="display:flex; align-items:center; gap:15px;">
                    <div class="diagonal-arrow down">
                      <div class="arrow">→</div>
                    </div>
                    <div style="position:relative;">
                      <div style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); font-size:13px; font-weight:600; text-decoration:underline; white-space:nowrap;">${method2}</div>
                      ${branch2Evo}
                    </div>
                    ${branch2Rest !== branch2Evo ? branch2Rest.replace(branch2Evo, '') : ''}
                  </div>
                </div>
              </div>
            `;
            return html;
        } else if(keys.length === 3) {
            // Three-way branch - branches on same horizontal line with middle one aligned
            const branches = await Promise.all(keys.map(async (nextName) => {
                const method = evolvesInto[nextName];
                const evoBlock = await renderEvo(nextName);
                const restOfChain = await buildChain(nextName);
                return {
                    html: `
                      <div style="display:flex; align-items:center; gap:15px;">
                        ${renderArrow(method)}
                        ${evoBlock}
                        ${restOfChain !== evoBlock ? restOfChain.replace(evoBlock, '') : ''}
                      </div>
                    `,
                };
            }));
            
            html = `
              <div class="branch-container">
                <div class="pre-evo-centered">
                  ${html}
                </div>
                <div class="branch-column">
                  ${branches.map(b => b.html).join('')}
                </div>
              </div>
            `;
            return html;
        } else {
            // Multi-way branch (4+) - vertical stack
            const branches = await Promise.all(keys.map(async (nextName) => {
                const method = evolvesInto[nextName];
                const evoBlock = await renderEvo(nextName);
                const restOfChain = await buildChain(nextName);
                return `
                  <div class="branch-group">
                    ${renderArrow(method, true)}
                    ${evoBlock}
                    ${restOfChain !== evoBlock ? restOfChain.replace(evoBlock, '') : ''}
                  </div>
                `;
            }));
            
            html = `
              <div class="multi-branch-container">
                ${html}
                <div class="branch-container">
                  ${branches.join('')}
                </div>
              </div>
            `;
            return html;
        }
    };

    buildChain(pointer).then(chainHtml => {
        evoContainer.innerHTML = chainHtml || "<p>No evolution data available.</p>";
    });
}
</script>

</body>
</html>
