<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Battles and Encounters</title>

    <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@300;400;600&display=swap" rel="stylesheet">

    <!-- Standardized header styles & script -->
    <link rel="stylesheet" href="header.css">
    <script src="header.js" defer></script>

    <link rel="stylesheet" href="style.css">
    <style>
        :root{
            --poke-border: 2px;
            --trainer-border-color: #6f6f6f; /* darker trainer-row border */
            --pokemon-border-color: #555555;  /* darker border for each pokemon entry */
            --inner-padding-x: 10px;
            --inner-padding-y: 12px;
            --moves-separator-thick: 4px; /* thickness for separators */
            --sep-color: #e6e6e6;
            --items-section-bg: #6a6a6a; /* background for items section */
        }

        /* base layout */
        body {
            font-family: 'Lexend', sans-serif;
            background: #f5f5f5;
            margin: 0;
            padding: 0;
            display: flex;
        }

        .sidebar {
            position: fixed;
            top: 65px;
            left: 0;
            width: 320px;
            height: calc(100vh - 65px);
            background: white;
            overflow-y: auto;
            box-shadow: 3px 0 8px rgba(0,0,0,0.07);
            padding: 15px;
        }

        .route-tab {
            padding: 10px 12px;
            margin-bottom: 8px;
            background: #f2f2f2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .route-tab:hover {
            background: #e3e3e3;
        }

        .route-tab.active {
            background: #1976d2;
            color: white;
            font-weight: 600;
        }

        .trainer-section {
            padding: 20px;
            max-width: 1600px;
            margin-left: 340px;
            margin-top: 90px;
            width: calc(100% - 340px);
        }

        .route-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }
        
        .area-title {
            font-size: 1.8rem;
            font-weight: 700;
            flex: 1;
            text-align: center;
        }
        
        .nav-button {
            padding: 10px 20px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: background 0.2s;
            min-width: 120px;
        }
        
        .nav-button:hover:not(:disabled) {
            background: #1565c0;
        }
        
        .nav-button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .nav-button-prev {
            margin-right: auto;
        }
        
        .nav-button-next {
            margin-left: auto;
        }

        /* Tab navigation styles */
        .content-tabs {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid #ddd;
            flex-wrap: wrap;
        }

        .tab-button {
            padding: 10px 20px;
            background: #f5f5f5;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.2s;
            border-radius: 8px 8px 0 0;
        }

        .tab-button:hover {
            background: #e3e3e3;
        }

        .tab-button.active {
            background: white;
            border-bottom-color: #1976d2;
            color: #1976d2;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Encounter-related styles */
        .encounter-type-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .encounter-type-header {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 3px solid #1976d2;
        }

        .items-section {
            background: var(--items-section-bg);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            text-align: center;
            color: #666;
            font-style: italic;
        }

        .pokemon-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }

        .pokemon-box {
            background: #fafafa;
            border: 2px solid var(--pokemon-border-color);
            border-radius: 10px;
            padding: 10px;
            width: 100px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .pokemon-name {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }

        .pokemon-icon {
            width: 60px;
            height: 60px;
            object-fit: contain;
            image-rendering: pixelated;
            margin: 5px auto;
            display: block;
            cursor: pointer;
        }
        
        .pokemon-icon:hover {
            opacity: 0.8;
            transform: scale(1.05);
            transition: all 0.2s ease;
        }

        .pokemon-chance {
            font-weight: 600;
            color: #1976d2;
            margin-top: 5px;
        }

        .na-message {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .sub-header {
            margin-top: 25px;
            font-size: 1.15rem;
            text-decoration: underline;
        }

        .trainer-card {
            background: white;
            padding: 12px;
            border-radius: 12px;
            margin: 15px 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }

        .trainer-header {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 16px;
            text-align: center;
        }

        .trainer-image {
            width: 150px;
            height: 150px;
            object-fit: contain;
            border-radius: 8px;
            display: block;
            margin: 50px auto;
        }
        
        /* Larger tooltip font size */
        [title] {
            cursor: help;
        }
        
        /* Override browser default tooltip styling with larger font */
        @supports (font-size: 16px) {
            [title]:hover::after {
                font-size: 16px;
            }
        }

        .trainer-sub {
            font-size: 0.95rem;
            color: #666;
            margin-bottom: 12px;
        }
        
        /* Bubble badges for battle info - positioned at bottom of trainer card */
        .trainer-badges {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 16px;
            align-items: center;
            flex-shrink: 0;
        }
        
        .info-bubble {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            color: white;
            min-width: 120px;
        }
        
        /* Battle Type colors */
        .battle-single { background: #6BAED6; } /* Light Blue */
        .battle-double { background: #D4A017; } /* Dark Yellow */
        .battle-triple { background: #5CB85C; } /* Green */
        .battle-rotation { background: #E75480; } /* Pink */
        
        /* Mandatory/Optional colors */
        .battle-mandatory { background: #DC3545; } /* Red */
        .battle-optional { background: #9B59B6; } /* Purple */
        
        /* Reward color */
        .battle-reward { background: #808080; } /* Grey */

        /* darker border for trainer entry rows */
        .trainer-row {
            display: flex;
            align-items: stretch;
            gap: 0;
            border: var(--poke-border) solid var(--trainer-border-color);
            border-radius: 10px;
            overflow: hidden;
            background: transparent;
        }

        .trainer-row > div { box-sizing: border-box; }

        .trainer-row > .trainer-info-column {
            width: 240px;
            min-width: 240px;
            max-width: 240px;
            padding: 12px;
            background: #ffffff;
            border-right: 1px solid #e6e6e6;
            border-top: 1px solid #e6e6e6;
            border-bottom: 1px solid #e6e6e6;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .trainer-row > .pokemon-container {
            display: flex;
            flex-wrap: wrap;
            flex: 1;
            align-items: stretch;
        }

        /*
          Each pokemon column has a full border. Inner content lives in .pokemon-inner.
          Separators between sections are implemented as pseudo-elements on the target
          elements and are sized so they connect to the outer borders of the pokemon column.
          
          Each column has a fixed equal width of 208px so all columns are uniformly sized.
          When there are 6 columns (240px trainer + 6Ã—208px = 1488px total), they fill the 
          entire available space without requiring horizontal scroll on standard screens.
        */
        .pokemon-container > .pokemon-col {
            width: 202px;
            min-width: 202px;
            max-width: 202px;
            padding: 0; /* inner wrapper controls padding */
            background: #fafafa;
            /* full, darker border around each pokemon column */
            border: var(--poke-border) solid var(--pokemon-border-color);
            box-sizing: border-box;
            background-clip: padding-box;
            position: relative;
        }

        /* slightly alternate backgrounds to improve readability */
        .pokemon-container > .pokemon-col:nth-child(2n) { background: #fbfbfc; }
        .pokemon-container > .pokemon-col:nth-child(2n+1) { background: #fafafa; }

        /* when adjacent columns appear, keep a thin visual divider by overlapping edges.
           use a slightly darker thin divider to match darker pokemon borders */
        .pokemon-container > .pokemon-col + .pokemon-col {
            margin-left: -2px; /* collapse overlapping edges so the thin line appears consistently */
            border-left: 1px solid var(--pokemon-border-color);
        }

        .pokemon-inner {
            padding: var(--inner-padding-y) var(--inner-padding-x);
            position: relative; /* needed for pseudo-element drawing */
        }

        .poke-img {
            width: 96px;
            height: 96px;
            image-rendering: pixelated;
            display: block;
            margin: 10px auto;
        }

        /*
          Info boxes: remove margins so layout is deterministic.
          We'll draw separators via ::before pseudo-elements so they span from the left outer border
          to the right outer border of the pokemon-col.
        */
        .pokemon-inner .info-box {
            background: transparent;
            padding: 12px 0; /* vertical spacing inside each info block so top/bottom equal to separator */
            margin: 0;
            font-size: 0.95rem;
            text-align: left;
            font-weight: 700;
            color: #111;
            position: relative;
        }

        .pokemon-inner .types {
            text-align: center;
            margin: 0 0 0 0;
            position: relative;
            padding: 12px 0; /* match spacing of info-box so separators align evenly */
        }

        /*
          Draw thick separators using pseudo-elements so they reach the left/right outer borders.
          The left/right offsets include --inner-padding-x plus the border width so the line meets the border.
        */
        .pokemon-inner .types + .info-box::before,
        .pokemon-inner .info-box + .info-box::before,
        .pokemon-inner .move-list::before {
            content: "";
            position: absolute;
            left: calc(-1 * var(--inner-padding-x) - var(--poke-border));
            right: calc(-1 * var(--inner-padding-x) - var(--poke-border));
            height: var(--moves-separator-thick);
            background: var(--sep-color);
            top: 0; /* sits at top edge of the element */
            z-index: 2;
        }

        /* make separator between move header and the moves themselves pronounced as well */
        .move-list .move-header {
            font-weight: 700;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: var(--moves-separator-thick) solid var(--sep-color); /* thick under-header separator */
            position: relative;
            z-index: 2;
        }

        /* ensure move-list spacing and that the pseudo separator doesn't overlap header text */
        .move-list {
            margin: 8px 0 0 0;
            position: relative;
            padding-top: 8px;
        }

        .move-list .move-item {
            padding: 6px 0;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.85rem;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }
        
        .move-item .move-name {
            flex: 1;
        }
        
        .move-item .move-info {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .move-item .type-badge {
            font-size: 0.7rem;
            padding: 2px 6px;
        }
        
        .move-item .category-icon {
            width: 20px;
            height: 20px;
            object-fit: contain;
        }
        
        .item-icon {
            width: 20px;
            height: 20px;
            object-fit: contain;
            margin-left: 6px;
            vertical-align: middle;
        }
        
        .reward-item-icon {
            width: 18px;
            height: 18px;
            object-fit: contain;
            margin-left: 6px;
            vertical-align: middle;
        }

        .move-list .move-item:last-child { border-bottom: none; }

        .poke-name a { color: #000; text-decoration: none; }
        .poke-name { padding-bottom: 6px; display:block; }

        .type-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            margin: 2px 4px;
        }

        /* Type colors */
        .type-normal  { background:#A8A77A; }
        .type-fire    { background:#EE8130; }
        .type-water   { background:#6390F0; }
        .type-electric{ background:#F7D02C; color:#222; }
        .type-grass   { background:#7AC74C; }
        .type-ice     { background:#96D9D6; color:#222; }
        .type-fighting{ background:#C22E28; }
        .type-poison  { background:#A33EA1; }
        .type-ground  { background:#E2BF65; color:#222; }
        .type-flying  { background:#A98FF3; }
        .type-psychic { background:#F95587; }
        .type-bug     { background:#A6B91A; }
        .type-rock    { background:#B6A136; color:#222; }
        .type-ghost   { background:#735797; }
        .type-dragon  { background:#6F35FC; }
        .type-dark    { background:#705746; }
        .type-steel   { background:#B7B7CE; color:#222; }
        .type-fairy   { background:#D685AD; color:#222; }

        /* responsive tweaks */
        @media (max-width:1000px) {
            .trainer-section { width: calc(100% - 340px); }
            .trainer-row > .pokemon-col { width: 180px; min-width: 180px; max-width: 180px; }
        }
        @media (max-width:860px){
            .poke-name { max-width:140px; }
        }

        @media (max-width:520px){
            .trainer-section { margin-left: 16px; width: calc(100% - 16px); }
            .trainer-row { flex-direction: column; gap: 12px; border: none; background: transparent; }
            .trainer-row > .pokemon-col { width: 100%; min-width: 0; max-width: 100%; border: var(--poke-border) solid var(--pokemon-border-color); margin-left: 0; }
            .trainer-row > div:first-child { width: 100%; min-width: 0; max-width: 100%; }
            .pokemon-box { width: 100%; }
            .pokemon-inner { padding: var(--inner-padding-y) var(--inner-padding-x); }
        }
    </style>
</head>

<body>

<div class="sidebar" id="sidebar"></div>

<div class="trainer-section" id="trainerSection"></div>

<script>
    let trainerData = {};
    let groupedRoutes = {};
    let pokedexData = {}; // will hold pokedex.json entries keyed by original name
    let movesData = {}; // will hold moves.json entries for type and category info
    let abilitiesData = {}; // will hold abilities.json entries for tooltips
    let encounterData = []; // will hold encounters.json array
    let itemsData = []; // will hold items.json array
    let currentTab = 'battles'; // track active tab: 'battles', 'encounters', or 'items'
    let currentRoute = null; // track current route for tab persistence

    // When deciding sidebar order we prefer routeOrder; fallback to alphabetical
    let routeOrder = [
        "Aquacorde Town","Route 2","Santalune Forest","Route 3","Route 22","Route 22 - Part 2",
        "Santalune City","Santalune Gym","Route 4","Lumiose City","Route 5","Camphrier Town",
        "Route 6","Route 6 - Pathway","Route 6 - East","Route 6 - West","Route 7",
        "Connecting Cave","Route 8","Route 8 - Upper","Route 8 - Lower","Route 8 - Sea",
        "Route 9","Glittering Cave","Ambrette Town Aqaurium","Route 10","Cyllage City",
        "Cyllage Gym","Geosenge Town","Geosenge Town - Part 2","Route 11","Reflection Cave",
        "Reflection Cave - 1F","Reflection Cave - B1F","Tower of Mastery","Shalour Gym",
        "Route 12","Azure Bay","Coumarine City","Coumarine City - Seaside",
        "Coumarine City - Cliffside","Coumarine Gym","Route 13/Kalos Power Plant",
        "Route 13/Kalos Power Plant - Route 13","Route 13/Power Plant - Kalos Power Plant",
        "Lumiose Gym/Prism Tower", "Lumiose Gym/Prism Tower - Prism Tower", "Lumiose Gym/Prism Tower - Lumiose Gym", "Route 14","Laverre City","Laverre Gym","Poke Ball Factory","Route 15",
        "Route 16","Lost Hotel","Dendemille Town","Frost Cavern",
        "Frost Cavern - Outside","Frost Cavern - 1F","Frost Cavern - 2F","Frost Cavern - 3F",
        "Route 17","Anistar City","Anistar Gym","Lysandre Cafe/Lysandre Labs",
        "Lysandre Cafe/Lysandre Labs - Lysandre Cafe","Lysandre Labs - B1",
        "Lysandre Labs - B3","Team Flare Secret HQ - Entrance",
        "Team Flare Secret HQ - Walkway","Route 18","Terminus Cave","Terminus Cave - B1F",
        "Terminus Cave - B2F","Couriway Town","Route 19","Route 20","Snowbelle City",
        "Snowbelle Gym","Route 21","Victory Road","Victory Road - Entrance",
        "Victory Road - Inside 1","Victory Road - Outside 2","Victory Road - Inside 2",
        "Victory Road - Outside 3","Victory Road - Inside 3","Victory Road - Outside 4",
        "Victory Road - Inside 4","Elite Four/Kalos League Champion",
        "Elite Four/Kalos League Champion - Elite Four",
        "Elite Four/Kalos League Champion - Kalos League Champion","Lumiose Parade"
    ];

    const statColors = {
        "Atk": "#FF4500",
        "Def": "#FFD700",
        "SpA": "#1E90FF",
        "SpD": "#32CD32",
        "Spe": "#9400D3"
    };

    function colorNature(raw) {
        if (!raw) return raw;
        const plus = raw.match(/\+([A-Za-z]+)/);
        if (!plus) return raw;
        const stat = plus[1];
        const color = statColors[stat] || "#000";
        return `<span class="nature-colored" style="color:${color}">${raw}</span>`;
    }
    
    // Normalize item name to match image file naming convention (lowercase with hyphens)
    function normalizeItemName(itemName) {
        if (!itemName || itemName === "No Item" || itemName === "No Reward") return null;
        // Convert to lowercase and replace spaces with hyphens
        return itemName.toLowerCase().replace(/\s+/g, '-');
    }
    
    // Create an item icon image element
    function createItemIcon(itemName, className = 'item-icon') {
        const normalized = normalizeItemName(itemName);
        if (!normalized) return '';
        return `<img class="${className}" src="image/item/${normalized}.png" alt="${itemName}" title="${itemName}" onerror="this.style.display='none'">`;
    }
    
    // Find an ability entry by name with best-effort normalization
    function findAbilityEntry(abilityName) {
        if (!abilitiesData || !abilityName || abilityName === "---") return null;
        // Try direct lookup first
        if (abilitiesData[abilityName]) return abilitiesData[abilityName];
        // Try normalized lookup
        const target = normalizeForCompare(abilityName);
        for (const key in abilitiesData) {
            if (normalizeForCompare(key) === target) return abilitiesData[key];
        }
        return null;
    }

    // Find a move entry by name with best-effort normalization
    function findMoveEntry(moveName) {
        if (!movesData || !moveName || moveName === "---") return null;
        if (movesData[moveName]) return movesData[moveName];
        const target = normalizeForCompare(moveName);
        for (const key in movesData) {
            if (normalizeForCompare(key) === target) return movesData[key];
        }
        return null;
    }

    // Normalize helper for comparisons
    function normalizeForCompare(s) {
        return (s || "").toString().toLowerCase().replace(/[^a-z0-9]/g, "");
    }

    // Find a pokedex entry by name with best-effort normalization
    function findPokedexEntry(pokeName) {
        if (!pokedexData || !pokeName) return null;
        if (pokedexData[pokeName]) return pokedexData[pokeName];
        const target = normalizeForCompare(pokeName);
        for (const key in pokedexData) {
            if (normalizeForCompare(key) === target) return pokedexData[key];
        }
        return null;
    }

    // Determine the best "root" tab name for a given full area name by matching against routeOrder,
    // falling back to the left-most token before a slash/backslash or the original left-of-dash.
    function findRootForArea(fullAreaName) {
        const leftOfDash = (fullAreaName || "").split(" - ")[0].trim();
        const leftNorm = normalizeForCompare(leftOfDash);

        // Try to match against routeOrder entries (prefer exact matches only to avoid grouping Route 2 with Route 20/22)
        for (const candidate of routeOrder) {
            const candLeft = (candidate || "").split(" - ")[0].trim();
            const candNorm = normalizeForCompare(candLeft);

            if (!candNorm) continue;
            // Only use exact matches to prevent "Route 2" from matching "Route 20", "Route 22", etc.
            if (leftNorm === candNorm) return candLeft.split(/[\/\\]/)[0].trim();

            // check parts for matches (handle "Route 13" vs "Route 13/Power Plant")
            const leftParts = leftOfDash.split(/[\/\\]/).map(p=>p.trim()).filter(Boolean);
            const candParts = candLeft.split(/[\/\\]/).map(p=>p.trim()).filter(Boolean);
            for (const lp of leftParts) {
                for (const cp of candParts) {
                    if (normalizeForCompare(lp) === normalizeForCompare(cp)) {
                        return candLeft.split(/[\/\\]/)[0].trim();
                    }
                }
            }
        }

        // fallback: use the first token before slash/backslash or the leftOfDash itself
        const root = leftOfDash.split(/[\/\\]/)[0].trim();
        return root || leftOfDash;
    }

    // Choose a preferred tab label for a grouped root key.
    // Prefer a routeOrder entry that contains a slash/backslash (e.g. "Route 13/Power Plant"),
    // or that includes the more specific phrasing. If none, return the root itself.
    function preferredTabLabelForRoot(rootKey) {
        const rootNorm = normalizeForCompare(rootKey);
        // Try to find a routeOrder entry whose left-of-dash normalized equals rootNorm and that contains '/' or '\'
        for (const candidate of routeOrder) {
            const left = (candidate || "").split(" - ")[0].trim();
            if (!left) continue;
            if (normalizeForCompare(left).startsWith(rootNorm) || rootNorm.startsWith(normalizeForCompare(left))) {
                if (left.includes("/") || left.includes("\\")) return left;
            }
        }
        // Next prefer any routeOrder entry that contains the root (without requiring slash)
        for (const candidate of routeOrder) {
            const left = (candidate || "").split(" - ")[0].trim();
            if (!left) continue;
            if (normalizeForCompare(left) === rootNorm) return left;
        }
        // else just return the rootKey as-is
        return rootKey;
    }

    // routeIndexFor used for sorting subareas in a group
    function routeIndexFor(name) {
        if (!name) return Infinity;
        // exact match
        let i = routeOrder.indexOf(name);
        if (i !== -1) return i;
        // compare left-of-' - ' then left-of-'/' or '\' to each routeOrder item
        const nameLeft = name.split(" - ")[0].split(/[\/\\]/)[0].trim();
        for (let j = 0; j < routeOrder.length; j++) {
            const candidate = routeOrder[j];
            const candLeft = candidate.split(" - ")[0].split(/[\/\\]/)[0].trim();
            if (candLeft === nameLeft) return j;
        }
        return Infinity;
    }

    // ===== ENCOUNTER AND ITEMS HELPER FUNCTIONS =====
    
    function getPokemonIconPath(pokemonName) {
        const normalized = pokemonName.toLowerCase().replace(/[^a-z0-9]/g, "");
        return `image/icons/${normalized}.png`;
    }

    function getItemIconPath(itemName) {
        let cleanedName = itemName.replace(/-\d+$/, '');
        if (cleanedName.toUpperCase().startsWith('TM')) {
            return 'image/item/tm.png';
        }
        if (cleanedName.toUpperCase().startsWith('HM')) {
            return 'image/item/hm.png';
        }
        const filename = cleanedName.toLowerCase()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/\s+/g, '-')
            .replace(/-+/g, '-');
        return `image/item/${filename}.png`;
    }

    function parseAreaAndSubArea(area) {
        const match = area.match(/^(.+?)\s*\((.+?)\)$/);
        if (match) {
            return {
                mainArea: match[1].trim(),
                subArea: match[2].trim()
            };
        }
        return {
            mainArea: area,
            subArea: ""
        };
    }

    function aggregateEncountersForIndices(indices) {
        const aggregatedEncounters = {
            grass: [],
            fishing: [],
            rockSmash: [],
            surfing: [],
            hordes: []
        };
        
        indices.forEach((locationIndex) => {
            const location = encounterData[locationIndex];
            if (!location || !location.Encounters || !Array.isArray(location.Encounters)) return;
            
            location.Encounters.forEach(encounter => {
                const type = encounter.EncounterType.toLowerCase();
                
                if (type.includes('horde')) {
                    aggregatedEncounters.hordes.push(encounter);
                } else if (type.includes('rock smash')) {
                    aggregatedEncounters.rockSmash.push(encounter);
                } else if (type.includes('surf')) {
                    aggregatedEncounters.surfing.push(encounter);
                } else if (type.includes('rod')) {
                    aggregatedEncounters.fishing.push(encounter);
                } else {
                    aggregatedEncounters.grass.push(encounter);
                }
            });
        });
        
        return aggregatedEncounters;
    }

    function displayEncounterSection(container, sectionTitle, encounters) {
        if (encounters.length === 0) {
            return;
        }

        const section = document.createElement("div");
        section.className = "encounter-type-section";

        const header = document.createElement("div");
        header.className = "encounter-type-header";
        header.textContent = sectionTitle;
        section.appendChild(header);

        const isHordeSection = sectionTitle.toLowerCase().includes('horde');
        
        if (isHordeSection) {
            const pokemonBySpecies = new Map();
            
            encounters.forEach(encounter => {
                const hordeMatch = encounter.EncounterType.match(/Horde \((\d+)%\)/);
                const hordePercent = hordeMatch ? parseInt(hordeMatch[1]) : 0;
                
                encounter.Slots.forEach(slot => {
                    const species = slot.Species;
                    if (!pokemonBySpecies.has(species)) {
                        pokemonBySpecies.set(species, {
                            Species: species,
                            hordeTypes: [],
                            totalPercent: 0
                        });
                    }
                    const pokemonData = pokemonBySpecies.get(species);
                    if (!pokemonData.hordeTypes.includes(hordePercent)) {
                        pokemonData.hordeTypes.push(hordePercent);
                        pokemonData.totalPercent += hordePercent;
                    }
                });
            });
            
            const grid = document.createElement("div");
            grid.className = "pokemon-grid";
            
            Array.from(pokemonBySpecies.values()).forEach(pokemonData => {
                const box = document.createElement("div");
                box.className = "pokemon-box";

                const name = document.createElement("div");
                name.className = "pokemon-name";
                name.textContent = pokemonData.Species;
                box.appendChild(name);

                const iconLink = document.createElement("a");
                iconLink.href = `pokemon.html?name=${encodeURIComponent(pokemonData.Species)}`;
                iconLink.style.textDecoration = "none";
                
                const icon = document.createElement("img");
                icon.className = "pokemon-icon";
                icon.src = getPokemonIconPath(pokemonData.Species);
                icon.alt = pokemonData.Species;
                let iconFailed = false;
                icon.onerror = function() {
                    if (!iconFailed) {
                        iconFailed = true;
                        this.src = 'image/icons/unknown.png';
                    } else {
                        this.style.display = 'none';
                    }
                };
                iconLink.appendChild(icon);
                box.appendChild(iconLink);

                const chance = document.createElement("div");
                chance.className = "pokemon-chance";
                chance.textContent = `${pokemonData.totalPercent}%`;
                box.appendChild(chance);

                grid.appendChild(box);
            });
            
            section.appendChild(grid);
        } else {
            encounters.forEach((encounter, idx) => {
                let minLevel = Infinity;
                let maxLevel = -Infinity;
                encounter.Slots.forEach(slot => {
                    minLevel = Math.min(minLevel, slot.MinLevel);
                    maxLevel = Math.max(maxLevel, slot.MaxLevel);
                });
                
                let levelRange = "";
                if (minLevel !== Infinity && maxLevel !== -Infinity) {
                    if (minLevel === maxLevel) {
                        levelRange = ` (Lv. ${minLevel})`;
                    } else {
                        levelRange = ` (Lv. ${minLevel}-${maxLevel})`;
                    }
                }
                
                const showSubHeader = encounter.EncounterType !== sectionTitle && 
                                     (idx === 0 || encounters[idx - 1].EncounterType !== encounter.EncounterType);
                
                if (showSubHeader) {
                    const subHeader = document.createElement("div");
                    subHeader.style.fontSize = "1.1rem";
                    subHeader.style.fontWeight = "600";
                    subHeader.style.marginTop = "15px";
                    subHeader.style.marginBottom = "10px";
                    subHeader.style.color = "#555";
                    subHeader.textContent = encounter.EncounterType + levelRange;
                    section.appendChild(subHeader);
                }

                const pokemonMap = new Map();
                
                encounter.Slots.forEach(slot => {
                    const species = slot.Species;
                    if (pokemonMap.has(species)) {
                        const existing = pokemonMap.get(species);
                        const existingChance = parseFloat(existing.Chance.replace('%', '')) || 0;
                        const newChance = parseFloat(slot.Chance.replace('%', '')) || 0;
                        existing.Chance = `${existingChance + newChance}%`;
                    } else {
                        pokemonMap.set(species, {
                            Species: species,
                            Chance: slot.Chance || ""
                        });
                    }
                });

                const grid = document.createElement("div");
                grid.className = "pokemon-grid";

                Array.from(pokemonMap.values()).forEach(pokemonData => {
                    const box = document.createElement("div");
                    box.className = "pokemon-box";

                    const name = document.createElement("div");
                    name.className = "pokemon-name";
                    name.textContent = pokemonData.Species;
                    box.appendChild(name);

                    const iconLink = document.createElement("a");
                    iconLink.href = `pokemon.html?name=${encodeURIComponent(pokemonData.Species)}`;
                    iconLink.style.textDecoration = "none";
                    
                    const icon = document.createElement("img");
                    icon.className = "pokemon-icon";
                    icon.src = getPokemonIconPath(pokemonData.Species);
                    icon.alt = pokemonData.Species;
                    let iconFailed = false;
                    icon.onerror = function() {
                        if (!iconFailed) {
                            iconFailed = true;
                            this.src = 'image/icons/unknown.png';
                        } else {
                            this.style.display = 'none';
                        }
                    };
                    iconLink.appendChild(icon);
                    box.appendChild(iconLink);

                    if (pokemonData.Chance) {
                        const chance = document.createElement("div");
                        chance.className = "pokemon-chance";
                        chance.textContent = pokemonData.Chance;
                        box.appendChild(chance);
                    }

                    grid.appendChild(box);
                });

                section.appendChild(grid);
            });
        }

        container.appendChild(section);
    }

    function displayItemsSection(container, locationName) {
        const itemsSection = document.createElement("div");
        itemsSection.className = "items-section";
        itemsSection.style.marginTop = "30px";

        const header = document.createElement("h3");
        header.textContent = "Items";
        header.style.borderBottom = "2px solid #2196F3";
        header.style.paddingBottom = "10px";
        header.style.marginBottom = "20px";
        header.style.color = "#ffffff";
        itemsSection.appendChild(header);

        const locationItems = itemsData.filter(item => {
            const parsed = parseAreaAndSubArea(item.Area);
            return parsed.mainArea === locationName;
        });

        if (locationItems.length === 0) {
            const noItems = document.createElement("p");
            noItems.textContent = "Items information will be added in a future update.";
            noItems.style.color = "#cccccc";
            noItems.style.textAlign = "center";
            noItems.style.padding = "20px";
            itemsSection.appendChild(noItems);
        } else {
            const itemsBySubArea = new Map();
            locationItems.forEach(item => {
                const parsed = parseAreaAndSubArea(item.Area);
                const subArea = parsed.subArea || "General";
                if (!itemsBySubArea.has(subArea)) {
                    itemsBySubArea.set(subArea, []);
                }
                itemsBySubArea.get(subArea).push(item);
            });

            itemsBySubArea.forEach((items, subArea) => {
                if (subArea !== "General") {
                    const subAreaHeader = document.createElement("div");
                    subAreaHeader.textContent = subArea;
                    subAreaHeader.style.fontSize = "1.1rem";
                    subAreaHeader.style.fontWeight = "600";
                    subAreaHeader.style.marginTop = "20px";
                    subAreaHeader.style.marginBottom = "10px";
                    subAreaHeader.style.color = "#ffffff";
                    itemsSection.appendChild(subAreaHeader);
                }

                const table = document.createElement("table");
                table.style.width = "100%";
                table.style.borderCollapse = "collapse";
                table.style.marginBottom = "20px";

                const thead = document.createElement("thead");
                thead.innerHTML = `
                    <tr style="background-color: #f5f5f5; border-bottom: 2px solid #ddd;">
                        <th style="padding: 10px; text-align: center; width: 60px;">Icon</th>
                        <th style="padding: 10px; text-align: center;">Item</th>
                        <th style="padding: 10px; text-align: center;">Location/Price</th>
                    </tr>
                `;
                table.appendChild(thead);

                const tbody = document.createElement("tbody");
                items.forEach((item, idx) => {
                    const row = document.createElement("tr");
                    row.style.borderBottom = "1px solid #eee";
                    if (idx % 2 === 0) {
                        row.style.backgroundColor = "#fafafa";
                    }

                    const iconCell = document.createElement("td");
                    iconCell.style.padding = "10px";
                    iconCell.style.textAlign = "center";
                    const icon = document.createElement("img");
                    icon.src = getItemIconPath(item.Item);
                    icon.alt = item.Item;
                    icon.style.width = "40px";
                    icon.style.height = "40px";
                    icon.onerror = function() {
                        this.src = 'pokemon_sprites/unknown.png';
                        this.onerror = function() {
                            this.style.display = 'none';
                        };
                    };
                    iconCell.appendChild(icon);
                    row.appendChild(iconCell);

                    const nameCell = document.createElement("td");
                    nameCell.style.padding = "10px";
                    nameCell.style.fontWeight = "600";
                    nameCell.textContent = item.Item;
                    row.appendChild(nameCell);

                    const locationCell = document.createElement("td");
                    locationCell.style.padding = "10px";
                    locationCell.textContent = item["Location/Price"];
                    row.appendChild(locationCell);

                    tbody.appendChild(row);
                });
                table.appendChild(tbody);

                itemsSection.appendChild(table);
            });
        }

        container.appendChild(itemsSection);
    }

    // ===== END OF HELPER FUNCTIONS =====


    async function loadTrainers() {
        const sidebar = document.getElementById("sidebar");

        // Fetch trainers, pokedex, moves, abilities, encounters, and items data
        const [trainersRes, pokedexRes, movesRes, abilitiesRes, encountersRes, itemsRes] = await Promise.all([
            fetch("data/trainers.json"),
            fetch("data/pokedex.json"),
            fetch("data/moves.json"),
            fetch("data/abilities.json"),
            fetch("data/encounters.json"),
            fetch("data/items.json").catch(() => null)
        ]);
        trainerData = await trainersRes.json();
        pokedexData = await pokedexRes.json();
        movesData = await movesRes.json();
        abilitiesData = await abilitiesRes.json();
        encounterData = await encountersRes.json();
        if (itemsRes && itemsRes.ok) {
            itemsData = await itemsRes.json();
        }

        // Build groupedRoutes keyed by a root determined by findRootForArea
        groupedRoutes = {};
        for (const fullName in trainerData) {
            const root = findRootForArea(fullName);
            if (!groupedRoutes[root]) groupedRoutes[root] = [];
            groupedRoutes[root].push(fullName);
        }

        // Sort each group's subAreas using routeOrder when possible, else alphabetical
        Object.keys(groupedRoutes).forEach(root => {
            groupedRoutes[root].sort((a, b) => {
                const ia = routeIndexFor(a);
                const ib = routeIndexFor(b);
                if (ia === ib) return a.localeCompare(b);
                return ia - ib;
            });
        });

        // Build sidebar tabs using routeOrder preference but show preferred labels (may include slash)
        const added = new Set();
        for (const entry of routeOrder) {
            const rootCandidate = (entry || "").split(" - ")[0].split(/[\/\\]/)[0].trim();
            if (!rootCandidate) continue;
            // find matching groupedRoutes key (case-insensitive/normalized)
            const matchKey = Object.keys(groupedRoutes).find(k => normalizeForCompare(k) === normalizeForCompare(rootCandidate));
            if (!matchKey || added.has(matchKey)) continue;
            const displayLabel = preferredTabLabelForRoot(matchKey);
            const tab = document.createElement("div");
            tab.className = "route-tab";
            tab.dataset.base = matchKey;
            tab.textContent = displayLabel;
            tab.title = matchKey; // full root on hover
            tab.onclick = () => {
                document.querySelectorAll(".route-tab").forEach(t => t.classList.remove("active"));
                tab.classList.add("active");
                displayRoute(matchKey);
            };
            sidebar.appendChild(tab);
            added.add(matchKey);
        }

        // Append any remaining roots not in routeOrder (alphabetical), using preferred labels
        const remaining = Object.keys(groupedRoutes).filter(k => !added.has(k)).sort((a,b) => a.localeCompare(b));
        for (const root of remaining) {
            const displayLabel = preferredTabLabelForRoot(root);
            const tab = document.createElement("div");
            tab.className = "route-tab";
            tab.dataset.base = root;
            tab.textContent = displayLabel;
            tab.title = root;
            tab.onclick = () => {
                document.querySelectorAll(".route-tab").forEach(t => t.classList.remove("active"));
                tab.classList.add("active");
                displayRoute(root);
            };
            sidebar.appendChild(tab);
            added.add(root);
        }

        // Add encounter-only and item-only locations to sidebar
        // These are locations that don't have trainers but have encounters or items
        const encounterLocations = new Set();
        encounterData.forEach(location => {
            if (location.LocationName) {
                encounterLocations.add(location.LocationName);
            }
        });

        // Check items for additional locations
        if (itemsData && itemsData.length > 0) {
            itemsData.forEach(item => {
                const baseLocation = item.Area.replace(/\s*\([^)]*\)/, '').trim();
                if (baseLocation) {
                    encounterLocations.add(baseLocation);
                }
            });
        }

        // Add encounter/item-only locations that aren't already in the sidebar
        const encounterOnlyLocations = Array.from(encounterLocations).filter(loc => {
            // Check if this location is not already covered by trainer data
            const normalized = normalizeForCompare(loc);
            return !added.has(loc) && !Array.from(added).some(a => normalizeForCompare(a) === normalized);
        });

        // Sort encounter-only locations by routeOrder
        encounterOnlyLocations.sort((a, b) => {
            const ia = routeIndexFor(a);
            const ib = routeIndexFor(b);
            if (ia === ib) return a.localeCompare(b);
            return ia - ib;
        });

        // Add them to sidebar
        encounterOnlyLocations.forEach(locationName => {
            const tab = document.createElement("div");
            tab.className = "route-tab";
            tab.dataset.base = locationName;
            tab.textContent = locationName;
            tab.title = locationName;
            tab.onclick = () => {
                document.querySelectorAll(".route-tab").forEach(t => t.classList.remove("active"));
                tab.classList.add("active");
                displayRoute(locationName);
            };
            sidebar.appendChild(tab);
            added.add(locationName);
        });

        // Activate first tab if present
        if (sidebar.children.length) {
            sidebar.children[0].classList.add("active");
            displayRoute(sidebar.children[0].dataset.base);
        }
    }

    // Helper: derive subHeader label for a subArea key
    // If subArea has a ' - ' part, return that (right side).
    // Otherwise, if left-of-dash contains '/' or '\', return the last part (e.g., "Power Plant" from "Route 13/Power Plant").
    // Else return the left-of-dash itself.
    function getSubHeaderLabel(subAreaKey) {
        const parts = subAreaKey.split(" - ");
        if (parts.length > 1 && parts[1].trim()) return parts[1].trim();
        const left = parts[0].trim();
        const leftParts = left.split(/[\/\\]/).map(s => s.trim()).filter(Boolean);
        if (leftParts.length > 1) return leftParts[leftParts.length - 1]; // last part after slash/backslash
        return left;
    }

    // ===== TAB RENDERING FUNCTIONS =====

    function renderBattles(baseName, container) {
        // Find the subAreas for this base.
        const subAreas = groupedRoutes[baseName] || [];

        // Render each subArea with its own sub-header
        subAreas.forEach(subArea => {
            // Show the sub-header
            const subHeaderLabel = getSubHeaderLabel(subArea);
            const subHeader = document.createElement("div");
            subHeader.className = "sub-header";
            subHeader.textContent = subHeaderLabel;
            container.appendChild(subHeader);

            const areaData = trainerData[subArea];
            if (!areaData) return;

            areaData.Trainers.forEach(tr => {
                const card = document.createElement("div");
                card.className = "trainer-card";
                const row = document.createElement("div");
                row.className = "trainer-row";

                const trainerInfo = document.createElement("div");
                
                const normalizeString = (str) => {
                    return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "")
                        .toLowerCase().replace(/\s+/g, "");
                };
                
                const trainerImageFilename = normalizeString(tr.TrainerClass + " " + tr.TrainerName) + ".png";
                const trainerImagePath = `image/trainers/${trainerImageFilename}`;
                
                const trainerImageHtml = `<img class="trainer-image" src="${trainerImagePath}" alt="${tr.TrainerClass} ${tr.TrainerName}" onerror="this.style.display='none'">`;
                
                let rewardHtml = "";
                if (tr.Reward && tr.Reward !== "No Reward") {
                    const itemIcon = createItemIcon(tr.Reward);
                    if (itemIcon) {
                        rewardHtml = `<div class="trainer-reward">${itemIcon} <strong>Reward:</strong> ${tr.Reward}</div>`;
                    } else {
                        rewardHtml = `<div class="trainer-reward"><strong>Reward:</strong> ${tr.Reward}</div>`;
                    }
                }

                const specialBattleType = (tr["Battle Type"] && tr["Battle Type"] !== "Single") ? tr["Battle Type"] : "";
                const battleTypeHtml = specialBattleType ? `<div class="trainer-battle-type"><strong>Battle Type:</strong> ${specialBattleType}</div>` : "";

                let displayName = `${tr.TrainerClass} ${tr.TrainerName}`;
                const names = tr.TrainerName.split(" & ");
                const classes = tr.TrainerClass.split(" & ");
                if (names.length === 2 && classes.length === 2) {
                    displayName = `${classes[0]} ${names[0]} & ${classes[1]} ${names[1]}`;
                }

                trainerInfo.innerHTML = `
                    ${trainerImageHtml}
                    <div class="trainer-name">${displayName}</div>
                    ${rewardHtml}
                    ${battleTypeHtml}
                `;

                row.appendChild(trainerInfo);

                const pokemonContainer = document.createElement("div");
                pokemonContainer.style.display = "flex";
                pokemonContainer.style.flexWrap = "wrap";
                pokemonContainer.style.gap = "8px";

                tr.Pokemon.forEach(pk => {
                    const pDiv = document.createElement("div");
                    pDiv.className = "pokemon-col";

                    const pokeEntry = findPokedexEntry(pk.Species);
                    const types = [];
                    if (pokeEntry) {
                        if (pokeEntry.Type1) types.push(pokeEntry.Type1);
                        if (pokeEntry.Type2) types.push(pokeEntry.Type2);
                    }
                    const typesHtml = types.map(t => {
                        const sanitized = t.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                        return `<span class="type-badge type-${sanitized}">${t}</span>`;
                    }).join(' ');

                    const abilityEntry = findAbilityEntry(pk.Ability);
                    const abilityText = abilityEntry
                        ? `<strong>Ability:</strong> <span class="ability-tooltip" title="${abilityEntry.shortDesc || abilityEntry.effect || ''}">${pk.Ability}</span>`
                        : `<strong>Ability:</strong> ${pk.Ability}`;

                    const ivText = (pk.IV && pk.IV !== "---") ? pk.IV : "---";

                    const heldItemHtml = (pk.Item && pk.Item !== "No Item")
                        ? `<strong>Item:</strong> ${createItemIcon(pk.Item)} ${pk.Item}`
                        : `<strong>Item:</strong> None`;

                    const moves = pk.Moves ? pk.Moves.split(",").map(m => m.trim()).filter(Boolean) : [];
                    let movesHtml = '';
                    moves.forEach((moveName, idx) => {
                        const moveEntry = findMoveEntry(moveName);
                        let moveDisplay = moveName;
                        if (moveEntry) {
                            const moveType = moveEntry.Type || moveEntry.type || "unknown";
                            const moveCategory = moveEntry.Category || moveEntry.category || "???";
                            const moveDescription = moveEntry.description || "No description.";
                            const sanitizedType = moveType.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
                            moveDisplay = `
                                <span class="move-badge type-${sanitizedType}" title="${moveDescription}">
                                    ${moveName}
                                    <span class="move-category" style="margin-left:6px; font-weight:700; font-size:0.85em;">${moveCategory}</span>
                                </span>
                            `;
                        }
                        if (idx > 0 && idx % 2 === 0) {
                            movesHtml += `<div class="move-separator"></div>`;
                        }
                        movesHtml += `<div class="move-item">${moveDisplay}</div>`;
                    });

                    pDiv.innerHTML = `
                        <div class="pokemon-inner">
                            <div class="poke-name-row">
                                <div class="poke-name">${pk.Species}</div>
                                <div class="poke-level">Lv. ${pk.Level}</div>
                            </div>

                            <div class="info-box types-box">
                                ${typesHtml}
                            </div>

                            <div class="info-box">
                                ${abilityText}
                            </div>

                            <div class="info-box nature-box">
                                <strong>Nature:</strong> ${colorNature(pk.Nature)}
                            </div>

                            <div class="info-box iv-box">
                                <strong>IVs:</strong> ${ivText}
                            </div>

                            <div class="info-box item-box">
                                ${heldItemHtml}
                            </div>

                            <div class="info-box move-list">
                                <div class="move-header"><strong>Moves:</strong></div>
                                ${movesHtml}
                            </div>
                        </div>
                    `;

                    pokemonContainer.appendChild(pDiv);
                });
                
                row.appendChild(pokemonContainer);

                card.appendChild(row);
                container.appendChild(card);
            });
        });

        // If nothing was rendered (edge case), show fallback
        if (subAreas.length === 0) {
            const note = document.createElement("div");
            note.className = "muted";
            note.style.padding = "8px 6px";
            note.textContent = 'No trainers found for this area.';
            container.appendChild(note);
        }
    }

    function renderEncounters(baseName, container) {
        // Find matching encounters for this base location
        const encounterIndices = [];
        encounterData.forEach((location, index) => {
            if (normalizeForCompare(location.LocationName) === normalizeForCompare(baseName)) {
                encounterIndices.push(index);
            }
        });

        if (encounterIndices.length === 0) {
            const note = document.createElement("div");
            note.className = "na-message";
            note.textContent = 'No wild encounters found for this location.';
            container.appendChild(note);
            return;
        }

        // Aggregate encounters across all matching indices
        const aggregated = aggregateEncountersForIndices(encounterIndices);

        // Display each encounter type if it has data
        if (aggregated.grass.length > 0) {
            displayEncounterSection(container, "Grass/Flowers/Terrain", aggregated.grass);
        }
        if (aggregated.surfing.length > 0) {
            displayEncounterSection(container, "Surfing", aggregated.surfing);
        }
        if (aggregated.fishing.length > 0) {
            displayEncounterSection(container, "Fishing", aggregated.fishing);
        }
        if (aggregated.rockSmash.length > 0) {
            displayEncounterSection(container, "Rock Smash", aggregated.rockSmash);
        }
        if (aggregated.hordes.length > 0) {
            displayEncounterSection(container, "Horde Encounters", aggregated.hordes);
        }
    }

    function renderItems(baseName, container) {
        displayItemsSection(container, baseName);
    }

    // ===== END OF TAB RENDERING FUNCTIONS =====

    function displayRoute(baseName) {
        currentRoute = baseName; // Store for tab persistence
        const container = document.getElementById("trainerSection");
        container.innerHTML = "";
        
        // Get all route tabs to determine navigation
        const allTabs = Array.from(document.querySelectorAll(".route-tab"));
        const currentIndex = allTabs.findIndex(tab => tab.dataset.base === baseName);
        const hasPrev = currentIndex > 0;
        const hasNext = currentIndex < allTabs.length - 1;
        
        // Helper function to create navigation buttons (used at top and bottom)
        function createNavigationButtons(includeTitle = true) {
            const navContainer = document.createElement("div");
            navContainer.className = "route-header-container";
            
            // Previous button
            const prevButton = document.createElement("button");
            prevButton.className = "nav-button nav-button-prev";
            if (hasPrev) {
                const prevTab = allTabs[currentIndex - 1];
                prevButton.textContent = `â† ${prevTab.textContent}`;
                prevButton.onclick = () => {
                    document.querySelectorAll(".route-tab").forEach(t => t.classList.remove("active"));
                    prevTab.classList.add("active");
                    displayRoute(prevTab.dataset.base);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };
            } else {
                prevButton.textContent = "â† Previous Route";
                prevButton.disabled = true;
            }
            navContainer.appendChild(prevButton);
            
            // Title (only for top navigation)
            if (includeTitle) {
                const areaTitle = document.createElement("div");
                areaTitle.className = "area-title";
                areaTitle.textContent = baseName;
                navContainer.appendChild(areaTitle);
            } else {
                // Empty spacer for bottom navigation
                const spacer = document.createElement("div");
                navContainer.appendChild(spacer);
            }
            
            // Next button
            const nextButton = document.createElement("button");
            nextButton.className = "nav-button nav-button-next";
            if (hasNext) {
                const nextTab = allTabs[currentIndex + 1];
                nextButton.textContent = `${nextTab.textContent} â†’`;
                nextButton.onclick = () => {
                    document.querySelectorAll(".route-tab").forEach(t => t.classList.remove("active"));
                    nextTab.classList.add("active");
                    displayRoute(nextTab.dataset.base);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };
            } else {
                nextButton.textContent = "Next Route â†’";
                nextButton.disabled = true;
            }
            navContainer.appendChild(nextButton);
            
            return navContainer;
        }
        
        // Add navigation buttons at the top (with title)
        const headerContainer = createNavigationButtons(true);
        container.appendChild(headerContainer);

        // Determine which tabs to show based on available data
        const hasBattles = (groupedRoutes[baseName] || []).length > 0;
        
        const encounterIndices = [];
        encounterData.forEach((location, index) => {
            if (normalizeForCompare(location.LocationName) === normalizeForCompare(baseName)) {
                encounterIndices.push(index);
            }
        });
        const hasEncounters = encounterIndices.length > 0 && 
            encounterIndices.some(idx => {
                const loc = encounterData[idx];
                return loc && loc.Encounters && loc.Encounters.length > 0;
            });

        const hasItems = itemsData.some(item => {
            const parsed = parseAreaAndSubArea(item.Area);
            return parsed.mainArea === baseName;
        });

        // Create tabs container
        const tabsContainer = document.createElement("div");
        tabsContainer.className = "content-tabs";

        // Determine which tab to show
        const availableTabs = [];
        if (hasBattles) availableTabs.push('battles');
        if (hasEncounters) availableTabs.push('encounters');
        if (hasItems) availableTabs.push('items');

        // If current tab is not available, fall back to first available
        if (!availableTabs.includes(currentTab)) {
            currentTab = availableTabs[0] || 'battles';
        }

        // Create tab buttons
        if (hasBattles) {
            const battlesTab = document.createElement("button");
            battlesTab.className = "tab-button" + (currentTab === 'battles' ? ' active' : '');
            battlesTab.textContent = "Battles";
            battlesTab.onclick = (e) => switchTab('battles', e);
            tabsContainer.appendChild(battlesTab);
        }

        if (hasEncounters) {
            const encountersTab = document.createElement("button");
            encountersTab.className = "tab-button" + (currentTab === 'encounters' ? ' active' : '');
            encountersTab.textContent = "Encounters";
            encountersTab.onclick = (e) => switchTab('encounters', e);
            tabsContainer.appendChild(encountersTab);
        }

        if (hasItems) {
            const itemsTab = document.createElement("button");
            itemsTab.className = "tab-button" + (currentTab === 'items' ? ' active' : '');
            itemsTab.textContent = "Items";
            itemsTab.onclick = (e) => switchTab('items', e);
            tabsContainer.appendChild(itemsTab);
        }

        // Only show tabs if there are multiple types of content
        if (availableTabs.length > 0) {
            container.appendChild(tabsContainer);
        }

        // Create content containers for each tab
        const battlesContent = document.createElement("div");
        battlesContent.className = "tab-content" + (currentTab === 'battles' ? ' active' : '');
        battlesContent.id = "battles-content";

        const encountersContent = document.createElement("div");
        encountersContent.className = "tab-content" + (currentTab === 'encounters' ? ' active' : '');
        encountersContent.id = "encounters-content";

        const itemsContent = document.createElement("div");
        itemsContent.className = "tab-content" + (currentTab === 'items' ? ' active' : '');
        itemsContent.id = "items-content";

        // Render content for each tab
        if (hasBattles) {
            renderBattles(baseName, battlesContent);
        }
        if (hasEncounters) {
            renderEncounters(baseName, encountersContent);
        }
        if (hasItems) {
            renderItems(baseName, itemsContent);
        }

        container.appendChild(battlesContent);
        container.appendChild(encountersContent);
        container.appendChild(itemsContent);

        // Tab switching function
        function switchTab(tabName, event) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-content`).classList.add('active');
        }

        // If no content available at all, show message
        if (availableTabs.length === 0) {
            const note = document.createElement("div");
            note.className = "na-message";
            note.textContent = 'No data available for this location.';
            container.appendChild(note);
        }
        
        // Add navigation buttons at the bottom (without title)
        const footerContainer = createNavigationButtons(false);
        footerContainer.style.marginTop = "30px";
        container.appendChild(footerContainer);
    }

    loadTrainers();
</script>

</body>
</html>
